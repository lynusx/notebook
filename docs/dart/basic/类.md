# Dart 语言类（Class）详解

Dart 是一种面向对象的编程语言，类（Class）是 Dart 中实现面向对象编程的核心机制。通过类，开发者可以封装数据和行为，创建可复用、可维护的代码结构。本章将系统且全面地介绍 Dart 语言中的类系统，包括类的定义、属性、方法、构造函数、继承、抽象类、接口、混入（Mixin）、扩展方法以及 Dart 3.0 引入的新特性如类修饰符和扩展类型等。

## 第1章 类的定义与基础

在 Dart 中，类是创建对象的蓝图。一个类可以包含属性（数据）和方法（行为），通过实例化类可以创建具体的对象。

### 1.1 类的基本定义

使用 `class` 关键字定义一个类。类名通常采用大驼峰命名法（UpperCamelCase）。

```dart
class Person {
  // 属性（实例变量）
  String name;
  int age;
  
  // 构造函数
  Person(this.name, this.age);
  
  // 方法
  void introduce() {
    print('大家好，我是$name，今年$age岁。');
  }
}

void main() {
  // 创建类的实例
  var person = Person('Alice', 25);
  person.introduce();  // 输出: 大家好，我是Alice，今年25岁。
}
```

#### 1.1.1 类的成员

一个类主要包含两类成员：

1. **属性（Properties）**：用于存储对象的状态数据
2. **方法（Methods）**：用于定义对象的行为

```dart
class Car {
  // 实例属性
  String brand;
  String model;
  int year;
  
  // 类属性（静态属性）
  static int totalCars = 0;
  
  // 构造函数
  Car(this.brand, this.model, this.year) {
    totalCars++;
  }
  
  // 实例方法
  void displayInfo() {
    print('$brand $model ($year)');
  }
  
  // 类方法（静态方法）
  static void showTotal() {
    print('Total cars: $totalCars');
  }
}
```

### 1.2 属性详解

#### 1.2.1 实例属性

实例属性是属于对象实例的属性，每个实例都有自己独立的属性副本。

```dart
class Rectangle {
  double width;
  double height;
  
  Rectangle(this.width, this.height);
}

void main() {
  var rect1 = Rectangle(10, 20);
  var rect2 = Rectangle(5, 15);
  
  print(rect1.width);  // 输出: 10
  print(rect2.width);  // 输出: 5
}
```

#### 1.2.2 类属性（静态属性）

使用 `static` 关键字声明的属性属于类本身，而不是类的实例。所有实例共享同一个类属性。

```dart
class Counter {
  // 类属性
  static int count = 0;
  
  // 实例属性
  String name;
  
  Counter(this.name) {
    count++;  // 每创建一个实例，计数器加1
  }
  
  static void showCount() {
    print('Created $count instances');
  }
}

void main() {
  var c1 = Counter('A');
  var c2 = Counter('B');
  var c3 = Counter('C');
  
  Counter.showCount();  // 输出: Created 3 instances
  print(Counter.count);  // 输出: 3
}
```

#### 1.2.3 Getter 和 Setter

Dart 提供了 Getter 和 Setter 方法来控制对属性的访问和修改。这使得可以在访问或修改属性时执行额外的逻辑。

**Getter**

Getter 用于获取属性的值，可以像访问普通属性一样使用。

```dart
class Circle {
  double radius;
  
  Circle(this.radius);
  
  // Getter: 计算面积
  double get area => 3.14159 * radius * radius;
  
  // Getter: 计算周长
  double get circumference => 2 * 3.14159 * radius;
  
  // Getter: 带逻辑判断
  String get size {
    if (radius < 10) return 'small';
    if (radius < 50) return 'medium';
    return 'large';
  }
}

void main() {
  var circle = Circle(5);
  print(circle.area);           // 输出: 78.53975
  print(circle.circumference);  // 输出: 31.4159
  print(circle.size);           // 输出: small
}
```

**Setter**

Setter 用于设置属性的值，可以在赋值时执行验证或转换逻辑。

```dart
class Temperature {
  double _celsius = 0;  // 私有属性
  
  // Getter: 获取摄氏度
  double get celsius => _celsius;
  
  // Setter: 设置摄氏度（带验证）
  set celsius(double value) {
    if (value < -273.15) {
      throw ArgumentError('Temperature cannot be below absolute zero');
    }
    _celsius = value;
  }
  
  // Getter: 获取华氏度
  double get fahrenheit => _celsius * 9 / 5 + 32;
  
  // Setter: 设置华氏度
  set fahrenheit(double value) {
    celsius = (value - 32) * 5 / 9;  // 转换为摄氏度
  }
}

void main() {
  var temp = Temperature();
  temp.celsius = 25;
  print(temp.fahrenheit);  // 输出: 77.0
  
  temp.fahrenheit = 100;
  print(temp.celsius);     // 输出: 37.77777777777778
}
```

#### 1.2.4 私有属性

在 Dart 中，以下划线 `_` 开头的标识符是私有的，只能在定义它的库中访问。

```dart
class BankAccount {
  String owner;
  double _balance = 0;  // 私有属性
  
  BankAccount(this.owner);
  
  // Getter 用于访问私有属性
  double get balance => _balance;
  
  // 存款
  void deposit(double amount) {
    if (amount > 0) {
      _balance += amount;
      print('存入: \$$amount, 余额: \$$_balance');
    }
  }
  
  // 取款
  void withdraw(double amount) {
    if (amount > 0 && amount <= _balance) {
      _balance -= amount;
      print('取出: \$$amount, 余额: \$$_balance');
    } else {
      print('余额不足');
    }
  }
}

void main() {
  var account = BankAccount('Alice');
  account.deposit(1000);   // 输出: 存入: $1000, 余额: $1000
  account.withdraw(300);   // 输出: 取出: $300, 余额: $700
  
  // 通过 Getter 访问余额
  print('当前余额: \$${account.balance}');  // 输出: 当前余额: $700
  
  // account._balance = 9999;  // 错误: _balance 是私有的
}
```

**Dart Tips 语法小贴士**

Dart 的私有性是基于库的

与 Java 等语言不同，Dart 的私有性是基于库（library）而不是类的。这意味着同一个文件中的多个类可以互相访问彼此的私有成员。

```dart
// 在同一个库中
class A {
  int _private = 10;
}

class B {
  void accessA() {
    var a = A();
    print(a._private);  // 可以访问，因为在同一个库中
  }
}
```

### 1.3 方法详解

#### 1.3.1 实例方法

实例方法是属于对象实例的方法，可以访问实例的属性和方法。

```dart
class Calculator {
  double result = 0;
  
  void add(double value) {
    result += value;
  }
  
  void subtract(double value) {
    result -= value;
  }
  
  void multiply(double value) {
    result *= value;
  }
  
  void divide(double value) {
    if (value != 0) {
      result /= value;
    } else {
      print('Error: Division by zero');
    }
  }
  
  void clear() {
    result = 0;
  }
  
  void printResult() {
    print('Result: $result');
  }
}

void main() {
  var calc = Calculator();
  calc.add(10);
  calc.multiply(2);
  calc.subtract(5);
  calc.printResult();  // 输出: Result: 15.0
}
```

#### 1.3.2 类方法（静态方法）

使用 `static` 关键字声明的方法属于类本身，不能访问实例属性，只能访问类属性。

```dart
class MathUtils {
  static const double pi = 3.14159265359;
  
  // 静态方法: 计算平方
  static double square(double x) => x * x;
  
  // 静态方法: 计算立方
  static double cube(double x) => x * x * x;
  
  // 静态方法: 计算阶乘
  static int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
  }
  
  // 静态方法: 判断素数
  static bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
      if (n % i == 0) return false;
    }
    return true;
  }
}

void main() {
  print(MathUtils.pi);           // 输出: 3.14159265359
  print(MathUtils.square(5));    // 输出: 25.0
  print(MathUtils.cube(3));      // 输出: 27.0
  print(MathUtils.factorial(5)); // 输出: 120
  print(MathUtils.isPrime(17));  // 输出: true
}
```

#### 1.3.3 抽象方法

抽象方法是没有方法体的方法，必须在抽象类中声明。子类必须实现抽象方法。

```dart
abstract class Shape {
  // 抽象方法
  double getArea();
  double getPerimeter();
}

class Rectangle extends Shape {
  double width;
  double height;
  
  Rectangle(this.width, this.height);
  
  @override
  double getArea() => width * height;
  
  @override
  double getPerimeter() => 2 * (width + height);
}

class Circle extends Shape {
  double radius;
  
  Circle(this.radius);
  
  @override
  double getArea() => 3.14159 * radius * radius;
  
  @override
  double getPerimeter() => 2 * 3.14159 * radius;
}
```

#### 1.3.4 运算符重载

Dart 允许重载一些运算符，使类的实例可以使用运算符进行操作。

```dart
class Vector2D {
  final double x;
  final double y;
  
  const Vector2D(this.x, this.y);
  
  // 重载 + 运算符
  Vector2D operator +(Vector2D other) {
    return Vector2D(x + other.x, y + other.y);
  }
  
  // 重载 - 运算符
  Vector2D operator -(Vector2D other) {
    return Vector2D(x - other.x, y - other.y);
  }
  
  // 重载 * 运算符（数乘）
  Vector2D operator *(double scalar) {
    return Vector2D(x * scalar, y * scalar);
  }
  
  // 重载 == 运算符
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Vector2D) return false;
    return x == other.x && y == other.y;
  }
  
  // 重载 [] 运算符
  double operator [](int index) {
    if (index == 0) return x;
    if (index == 1) return y;
    throw RangeError('Index out of range');
  }
  
  @override
  int get hashCode => Object.hash(x, y);
  
  @override
  String toString() => 'Vector2D($x, $y)';
}

void main() {
  var v1 = Vector2D(3, 4);
  var v2 = Vector2D(1, 2);
  
  print(v1 + v2);        // 输出: Vector2D(4.0, 6.0)
  print(v1 - v2);        // 输出: Vector2D(2.0, 2.0)
  print(v1 * 2);         // 输出: Vector2D(6.0, 8.0)
  print(v1 == v2);       // 输出: false
  print(v1[0]);          // 输出: 3.0
}
```

## 第2章 构造函数

构造函数是用于创建类实例的特殊方法。Dart 提供了多种类型的构造函数，以满足不同的对象创建需求。

### 2.1 生成式构造函数

生成式构造函数是最常用的构造函数类型，用于创建类的新实例并初始化实例变量。

#### 2.1.1 默认构造函数

如果没有声明任何构造函数，Dart 会自动提供一个默认的无参构造函数。

```dart
class Point {
  double x = 0;
  double y = 0;
}

void main() {
  var point = Point();  // 使用默认构造函数
  print('(${point.x}, ${point.y})');  // 输出: (0.0, 0.0)
}
```

#### 2.1.2 普通构造函数

```dart
class Point {
  double x;
  double y;
  
  // 普通构造函数
  Point(double x, double y) {
    this.x = x;
    this.y = y;
  }
}
```

#### 2.1.3 初始化形式参数（简写语法）

Dart 提供了更简洁的语法，使用 `this.属性名` 直接在参数列表中初始化实例变量。

```dart
class Point {
  double x;
  double y;
  
  // 使用初始化形式参数
  Point(this.x, this.y);
}

void main() {
  var point = Point(3, 4);
  print('(${point.x}, ${point.y})');  // 输出: (3.0, 4.0)
}
```

**带默认值的初始化形式参数**

```dart
class Point {
  double x;
  double y;
  
  // 带默认值的命名参数
  Point({this.x = 0, this.y = 0});
  
  // 可选位置参数
  Point.optional([this.x = 0, this.y = 0]);
}

void main() {
  var p1 = Point();           // x=0, y=0
  var p2 = Point(x: 5);       // x=5, y=0
  var p3 = Point(x: 1, y: 2); // x=1, y=2
  var p4 = Point.optional(3); // x=3, y=0
}
```

### 2.2 命名构造函数

命名构造函数允许为类定义多个构造函数，并为每个构造函数提供有意义的名称。

```dart
class Point {
  final double x;
  final double y;
  
  // 主构造函数
  Point(this.x, this.y);
  
  // 命名构造函数: 原点
  Point.origin() : x = 0, y = 0;
  
  // 命名构造函数: 从 JSON 创建
  Point.fromJson(Map<String, double> json)
      : x = json['x'] ?? 0,
        y = json['y'] ?? 0;
  
  // 命名构造函数: 极坐标转换
  Point.fromPolar(double radius, double angle)
      : x = radius * cos(angle),
        y = radius * sin(angle);
  
  @override
  String toString() => 'Point($x, $y)';
}

void main() {
  var p1 = Point(3, 4);
  var p2 = Point.origin();
  var p3 = Point.fromJson({'x': 5, 'y': 6});
  var p4 = Point.fromPolar(10, 3.14159 / 4);
  
  print(p1);  // 输出: Point(3.0, 4.0)
  print(p2);  // 输出: Point(0.0, 0.0)
  print(p3);  // 输出: Point(5.0, 6.0)
  print(p4);  // 输出: Point(7.0710678118654755, 7.071067811865475)
}
```

### 2.3 初始化列表

初始化列表在构造函数体执行之前运行，用于初始化实例变量，特别是 `final` 变量。

```dart
class Rectangle {
  final double width;
  final double height;
  final double area;
  final double perimeter;
  
  Rectangle(double width, double height)
      : this.width = width,
        this.height = height,
        area = width * height,           // 在初始化列表中计算
        perimeter = 2 * (width + height)  // 在初始化列表中计算
  {
    print('Rectangle created: ${width}x${height}');
  }
}

// 带验证的初始化列表
class Person {
  final String name;
  final int age;
  
  Person(String name, int age)
      : name = name,
        age = age {
    // 在构造函数体中进行验证
    if (age < 0) {
      throw ArgumentError('Age cannot be negative');
    }
    if (name.isEmpty) {
      throw ArgumentError('Name cannot be empty');
    }
  }
}

// 使用 assert 进行验证
class PositiveNumber {
  final double value;
  
  PositiveNumber(this.value) : assert(value > 0, 'Value must be positive');
}
```

### 2.4 重定向构造函数

重定向构造函数将调用转发到同一类的另一个构造函数，使用 `this` 关键字。

```dart
class Point {
  double x;
  double y;
  
  // 主构造函数
  Point(this.x, this.y);
  
  // 重定向到主构造函数
  Point.alongXAxis(double x) : this(x, 0);
  
  // 重定向到主构造函数
  Point.alongYAxis(double y) : this(0, y);
  
  // 重定向到命名构造函数
  Point.origin() : this(0, 0);
}

void main() {
  var p1 = Point.alongXAxis(5);  // Point(5, 0)
  var p2 = Point.alongYAxis(3);  // Point(0, 3)
  var p3 = Point.origin();       // Point(0, 0)
}
```

### 2.5 常量构造函数

常量构造函数用于创建编译时常量对象。使用 `const` 关键字声明，所有实例变量必须是 `final`。

```dart
class ImmutablePoint {
  final double x;
  final double y;
  
  // 常量构造函数
  const ImmutablePoint(this.x, this.y);
  
  // 常量命名构造函数
  const ImmutablePoint.origin() : x = 0, y = 0;
  
  // 预定义的常量实例
  static const origin = ImmutablePoint(0, 0);
  static const unitX = ImmutablePoint(1, 0);
  static const unitY = ImmutablePoint(0, 1);
}

void main() {
  // 创建常量实例
  const p1 = ImmutablePoint(3, 4);
  const p2 = ImmutablePoint(3, 4);
  
  // 相同的常量值会共享同一个实例
  print(identical(p1, p2));  // 输出: true
  
  // 使用预定义的常量
  const p3 = ImmutablePoint.origin;
  print(p3.x);  // 输出: 0
}
```

**Flutter 框架小知识**

常量构造函数在 Flutter 中的优势

在 Flutter 中，使用 `const` 构造函数可以显著提高性能，因为相同的常量值会共享同一个实例，减少内存分配。

```dart
// 不推荐: 每次重建都创建新实例
Widget build(BuildContext context) {
  return Container(
    padding: EdgeInsets.all(16.0),  // 非 const
    child: Text('Hello'),            // 非 const
  );
}

// 推荐: 使用 const 构造函数
Widget build(BuildContext context) {
  return Container(
    padding: const EdgeInsets.all(16.0),  // const
    child: const Text('Hello'),            // const
  );
}
```

### 2.6 工厂构造函数

工厂构造函数使用 `factory` 关键字声明，它不总是创建新实例，可以返回缓存的实例、子类型实例，或者执行复杂的初始化逻辑。

#### 2.6.1 单例模式

```dart
class Singleton {
  static Singleton? _instance;
  
  // 私有命名构造函数
  Singleton._internal();
  
  // 工厂构造函数返回单例
  factory Singleton() {
    _instance ??= Singleton._internal();
    return _instance!;
  }
  
  void doSomething() {
    print('Singleton instance: $hashCode');
  }
}

void main() {
  var s1 = Singleton();
  var s2 = Singleton();
  
  print(identical(s1, s2));  // 输出: true
  s1.doSomething();
  s2.doSomething();  // 相同的 hashCode
}
```

#### 2.6.2 缓存实例

```dart
class User {
  final String name;
  final int id;
  
  static final Map<int, User> _cache = {};
  
  // 私有构造函数
  User._internal(this.id, this.name);
  
  // 工厂构造函数: 从缓存获取或创建
  factory User(int id, String name) {
    return _cache.putIfAbsent(id, () => User._internal(id, name));
  }
  
  // 工厂构造函数: 从 JSON 创建
  factory User.fromJson(Map<String, dynamic> json) {
    final id = json['id'] as int;
    final name = json['name'] as String;
    return User(id, name);  // 复用缓存工厂
  }
  
  static void clearCache() => _cache.clear();
}

void main() {
  var user1 = User(1, 'Alice');
  var user2 = User(1, 'Alice');
  var user3 = User(2, 'Bob');
  
  print(identical(user1, user2));  // 输出: true (同一缓存)
  print(identical(user1, user3));  // 输出: false (不同 id)
}
```

#### 2.6.3 返回子类型实例

```dart
abstract class Animal {
  String get name;
  void speak();
  
  // 工厂构造函数根据类型创建不同子类
  factory Animal(String type, String name) {
    switch (type) {
      case 'dog':
        return Dog(name);
      case 'cat':
        return Cat(name);
      case 'bird':
        return Bird(name);
      default:
        throw ArgumentError('Unknown animal type: $type');
    }
  }
}

class Dog implements Animal {
  @override
  final String name;
  Dog(this.name);
  
  @override
  void speak() => print('$name: Woof!');
}

class Cat implements Animal {
  @override
  final String name;
  Cat(this.name);
  
  @override
  void speak() => print('$name: Meow!');
}

class Bird implements Animal {
  @override
  final String name;
  Bird(this.name);
  
  @override
  void speak() => print('$name: Tweet!');
}

void main() {
  var dog = Animal('dog', 'Buddy');
  var cat = Animal('cat', 'Whiskers');
  var bird = Animal('bird', 'Tweety');
  
  dog.speak();   // 输出: Buddy: Woof!
  cat.speak();   // 输出: Whiskers: Meow!
  bird.speak();  // 输出: Tweety: Tweet!
}
```

### 2.7 构造函数继承

子类不继承父类的构造函数，但可以使用 `super` 调用父类的构造函数。

```dart
class Person {
  String name;
  int age;
  
  Person(this.name, this.age);
  
  Person.guest() : name = 'Guest', age = 0;
}

class Student extends Person {
  String school;
  
  // 调用父类构造函数
  Student(String name, int age, this.school) : super(name, age);
  
  // 调用父类命名构造函数
  Student.guest(String school) : super.guest(), school = school;
}

void main() {
  var s1 = Student('Alice', 20, 'MIT');
  print('${s1.name}, ${s1.age}, ${s1.school}');  // Alice, 20, MIT
  
  var s2 = Student.guest('Stanford');
  print('${s2.name}, ${s2.age}, ${s2.school}');  // Guest, 0, Stanford
}
```

#### 超参数（Super Parameters）

Dart 2.17+ 引入了超参数，可以简化向父类构造函数传递参数的过程。

```dart
class Person {
  String name;
  int age;
  
  Person({required this.name, required this.age});
}

class Student extends Person {
  String school;
  
  // 使用超参数简化
  Student({required super.name, required super.age, required this.school});
}

void main() {
  var student = Student(name: 'Alice', age: 20, school: 'MIT');
  print('${student.name}, ${student.age}, ${student.school}');
}
```

## 第3章 继承与多态

继承是面向对象编程的核心特性之一，允许子类继承父类的属性和方法，并可以添加新的功能或重写父类的方法。

### 3.1 基本继承

使用 `extends` 关键字实现继承。

```dart
class Animal {
  String name;
  int age;
  
  Animal(this.name, this.age);
  
  void eat() {
    print('$name is eating');
  }
  
  void sleep() {
    print('$name is sleeping');
  }
}

class Dog extends Animal {
  String breed;
  
  Dog(String name, int age, this.breed) : super(name, age);
  
  void bark() {
    print('$name: Woof! Woof!');
  }
  
  // 重写父类方法
  @override
  void eat() {
    print('$name (a $breed) is eating dog food');
  }
}

class Cat extends Animal {
  String color;
  
  Cat(String name, int age, this.color) : super(name, age);
  
  void meow() {
    print('$name: Meow~');
  }
  
  @override
  void eat() {
    print('$name (a $color cat) is eating fish');
  }
}

void main() {
  var dog = Dog('Buddy', 3, 'Golden Retriever');
  dog.eat();     // 输出: Buddy (a Golden Retriever) is eating dog food
  dog.sleep();   // 输出: Buddy is sleeping
  dog.bark();    // 输出: Buddy: Woof! Woof!
  
  var cat = Cat('Whiskers', 2, 'white');
  cat.eat();     // 输出: Whiskers (a white cat) is eating fish
  cat.meow();    // 输出: Whiskers: Meow~
}
```

### 3.2 方法重写

子类可以使用 `@override` 注解重写父类的方法。

```dart
class Shape {
  String get name => 'Shape';
  
  double getArea() => 0;
  double getPerimeter() => 0;
  
  void describe() {
    print('This is a $name');
    print('Area: ${getArea()}');
    print('Perimeter: ${getPerimeter()}');
  }
}

class Rectangle extends Shape {
  double width;
  double height;
  
  Rectangle(this.width, this.height);
  
  @override
  String get name => 'Rectangle';
  
  @override
  double getArea() => width * height;
  
  @override
  double getPerimeter() => 2 * (width + height);
}

class Circle extends Shape {
  double radius;
  
  Circle(this.radius);
  
  @override
  String get name => 'Circle';
  
  @override
  double getArea() => 3.14159 * radius * radius;
  
  @override
  double getPerimeter() => 2 * 3.14159 * radius;
}

void main() {
  List<Shape> shapes = [
    Rectangle(5, 3),
    Circle(4),
  ];
  
  for (var shape in shapes) {
    shape.describe();
    print('---');
  }
}
```

### 3.3 调用父类方法

使用 `super` 关键字调用父类的方法。

```dart
class Employee {
  String name;
  double salary;
  
  Employee(this.name, this.salary);
  
  void displayInfo() {
    print('Name: $name');
    print('Salary: \$$salary');
  }
}

class Manager extends Employee {
  String department;
  double bonus;
  
  Manager(String name, double salary, this.department, this.bonus)
      : super(name, salary);
  
  @override
  void displayInfo() {
    super.displayInfo();  // 调用父类方法
    print('Department: $department');
    print('Bonus: \$$bonus');
    print('Total Compensation: \$${salary + bonus}');
  }
}

void main() {
  var manager = Manager('Alice', 80000, 'Engineering', 20000);
  manager.displayInfo();
}
```

### 3.4 多态

多态允许将子类对象赋值给父类类型的变量，同一个方法调用可以有不同的执行结果。

```dart
abstract class PaymentMethod {
  void pay(double amount);
}

class CreditCard implements PaymentMethod {
  String cardNumber;
  
  CreditCard(this.cardNumber);
  
  @override
  void pay(double amount) {
    print('Paying \$$amount using Credit Card ending in ${cardNumber.substring(cardNumber.length - 4)}');
  }
}

class PayPal implements PaymentMethod {
  String email;
  
  PayPal(this.email);
  
  @override
  void pay(double amount) {
    print('Paying \$$amount using PayPal account $email');
  }
}

class CryptoWallet implements PaymentMethod {
  String walletAddress;
  
  CryptoWallet(this.walletAddress);
  
  @override
  void pay(double amount) {
    print('Paying \$$amount using Crypto Wallet $walletAddress');
  }
}

void processPayment(PaymentMethod method, double amount) {
  method.pay(amount);
}

void main() {
  PaymentMethod payment;
  
  payment = CreditCard('1234567890123456');
  processPayment(payment, 100.0);
  
  payment = PayPal('user@example.com');
  processPayment(payment, 50.0);
  
  payment = CryptoWallet('0x1234...');
  processPayment(payment, 200.0);
}
```

## 第4章 抽象类与接口

### 4.1 抽象类

抽象类使用 `abstract` 关键字声明，不能被实例化。抽象类可以包含抽象方法（没有方法体的方法）和具体方法。

```dart
abstract class Shape {
  // 抽象方法
  double getArea();
  double getPerimeter();
  
  // 具体方法
  void describe() {
    print('Area: ${getArea()}');
    print('Perimeter: ${getPerimeter()}');
  }
  
  // 命名构造函数
  Shape();
  
  // 工厂构造函数
  factory Shape.create(String type, double size) {
    switch (type) {
      case 'square':
        return Square(size);
      case 'circle':
        return Circle(size);
      default:
        throw ArgumentError('Unknown shape type');
    }
  }
}

class Square extends Shape {
  double side;
  
  Square(this.side);
  
  @override
  double getArea() => side * side;
  
  @override
  double getPerimeter() => 4 * side;
}

class Circle extends Shape {
  double radius;
  
  Circle(this.radius);
  
  @override
  double getArea() => 3.14159 * radius * radius;
  
  @override
  double getPerimeter() => 2 * 3.14159 * radius;
}

void main() {
  // Shape shape = Shape();  // 错误: 抽象类不能被实例化
  
  Shape square = Square(5);
  square.describe();
  
  Shape circle = Shape.create('circle', 3);
  circle.describe();
}
```

### 4.2 接口

Dart 没有专门的 `interface` 关键字，任何类都可以作为接口被实现。使用 `implements` 关键字实现接口。

```dart
// 作为接口的类
class Printable {
  void printDocument() {}
  void scanDocument() {}
}

class Scannable {
  void scan() {}
}

// 实现多个接口
class MultiFunctionPrinter implements Printable, Scannable {
  @override
  void printDocument() {
    print('Printing document...');
  }
  
  @override
  void scanDocument() {
    print('Scanning document...');
  }
  
  @override
  void scan() {
    print('Scanning...');
  }
  
  void fax() {
    print('Faxing...');
  }
}

void main() {
  var printer = MultiFunctionPrinter();
  printer.printDocument();
  printer.scanDocument();
  printer.scan();
  printer.fax();
}
```

### 4.3 抽象接口类（Dart 3.0+）

Dart 3.0 引入了 `interface` 修饰符，结合 `abstract` 可以创建纯接口。

```dart
// a.dart
abstract interface class Database {
  void connect();
  void disconnect();
  List<Map<String, dynamic>> query(String sql);
}

// b.dart
import 'a.dart';

// 可以实现接口
class MySQLDatabase implements Database {
  @override
  void connect() {
    print('Connecting to MySQL...');
  }
  
  @override
  void disconnect() {
    print('Disconnecting from MySQL...');
  }
  
  @override
  List<Map<String, dynamic>> query(String sql) {
    print('Executing: $sql');
    return [];
  }
}

// 错误: 不能继承接口类
// class CustomDB extends Database { ... }
```

## 第5章 混入（Mixin）

Mixin 是一种在多个类层次结构中复用代码的方式。与继承不同，Mixin 允许类获取功能而不需要成为子类。

### 5.1 定义 Mixin

使用 `mixin` 关键字定义 Mixin。

```dart
mixin Walkable {
  void walk() {
    print('Walking...');
  }
}

mixin Swimmable {
  void swim() {
    print('Swimming...');
  }
}

mixin Flyable {
  void fly() {
    print('Flying...');
  }
}

// 使用 with 关键字混入
class Human with Walkable {
  String name;
  
  Human(this.name);
}

class Duck with Walkable, Swimmable, Flyable {
  String name;
  
  Duck(this.name);
}

class Fish with Swimmable {
  String name;
  
  Fish(this.name);
}

void main() {
  var human = Human('Alice');
  human.walk();  // 输出: Walking...
  
  var duck = Duck('Donald');
  duck.walk();   // 输出: Walking...
  duck.swim();   // 输出: Swimming...
  duck.fly();    // 输出: Flying...
  
  var fish = Fish('Nemo');
  fish.swim();   // 输出: Swimming...
}
```

### 5.2 Mixin 中的方法重写

```dart
mixin Logger {
  void log(String message) {
    print('[LOG] $message');
  }
  
  void error(String message) {
    print('[ERROR] $message');
  }
}

class FileLogger with Logger {
  String fileName;
  
  FileLogger(this.fileName);
  
  @override
  void log(String message) {
    super.log(message);
    print('Writing to file: $fileName');
  }
}

void main() {
  var logger = FileLogger('app.log');
  logger.log('Application started');
}
```

### 5.3 使用 on 限制 Mixin 的使用

使用 `on` 关键字可以限制 Mixin 只能被特定类型的子类使用。

```dart
abstract class Animal {
  String name;
  
  Animal(this.name);
  
  void eat();
}

// 只能被 Animal 的子类使用
mixin Carnivore on Animal {
  void hunt() {
    print('$name is hunting...');
  }
  
  @override
  void eat() {
    print('$name is eating meat');
  }
}

mixin Herbivore on Animal {
  void graze() {
    print('$name is grazing...');
  }
  
  @override
  void eat() {
    print('$name is eating plants');
  }
}

class Lion extends Animal with Carnivore {
  Lion(String name) : super(name);
}

class Deer extends Animal with Herbivore {
  Deer(String name) : super(name);
}

// 错误: String 不是 Animal 的子类
// class MyClass with Carnivore { }

void main() {
  var lion = Lion('Simba');
  lion.hunt();  // 输出: Simba is hunting...
  lion.eat();   // 输出: Simba is eating meat
  
  var deer = Deer('Bambi');
  deer.graze();  // 输出: Bambi is grazing...
  deer.eat();    // 输出: Bambi is eating plants
}
```

### 5.4 Mixin 类（Mixin Class）

Dart 3.0 引入了 `mixin class`，既可以作为 Mixin 使用，也可以作为普通类使用。

```dart
// 既可以被 with，也可以被 extends
mixin class Counter {
  int _count = 0;
  
  void increment() => _count++;
  void decrement() => _count--;
  int get count => _count;
}

// 作为 Mixin 使用
class Button with Counter {
  void click() {
    increment();
    print('Button clicked ${count} times');
  }
}

// 作为类使用
class AdvancedCounter extends Counter {
  void reset() => _count = 0;
  
  void add(int value) => _count += value;
}

void main() {
  var button = Button();
  button.click();  // 输出: Button clicked 1 times
  button.click();  // 输出: Button clicked 2 times
  
  var counter = AdvancedCounter();
  counter.increment();
  counter.increment();
  print(counter.count);  // 输出: 2
  counter.add(5);
  print(counter.count);  // 输出: 7
  counter.reset();
  print(counter.count);  // 输出: 0
}
```

## 第6章 类修饰符（Dart 3.0+）

Dart 3.0 引入了类修饰符，用于控制类的使用方式，包括继承、实现和混入。

### 6.1 abstract 修饰符

抽象类不能被实例化，可以包含抽象方法。

```dart
abstract class Vehicle {
  void move();  // 抽象方法
  
  void stop() {  // 具体方法
    print('Vehicle stopped');
  }
}

// 可以继承
class Car extends Vehicle {
  @override
  void move() {
    print('Car is driving');
  }
}

// 可以实现
class Bicycle implements Vehicle {
  @override
  void move() {
    print('Bicycle is pedaling');
  }
  
  @override
  void stop() {
    print('Bicycle stopped');
  }
}

void main() {
  // Vehicle v = Vehicle();  // 错误: 抽象类不能被实例化
  
  Vehicle car = Car();
  car.move();  // 输出: Car is driving
  
  Vehicle bike = Bicycle();
  bike.move();  // 输出: Bicycle is pedaling
}
```

### 6.2 base 修饰符

基类强制子类继承其实现，不允许在其他库中实现。

```dart
// a.dart
base class Vehicle {
  void move() {
    print('Vehicle moving');
  }
}

// b.dart
import 'a.dart';

// 可以继承
base class Car extends Vehicle {
  @override
  void move() {
    print('Car driving');
  }
}

// 错误: 不能实现 base 类
// class MockVehicle implements Vehicle { }
```

### 6.3 interface 修饰符

接口类只能被实现，不能被继承。

```dart
// a.dart
interface class Logger {
  void log(String message) {
    print('LOG: $message');
  }
}

// b.dart
import 'a.dart';

// 可以实现
class FileLogger implements Logger {
  @override
  void log(String message) {
    print('Writing to file: $message');
  }
}

// 错误: 不能继承 interface 类
// class CustomLogger extends Logger { }
```

### 6.4 final 修饰符

最终类完全禁止被继承或实现，提供最严格的封装。

```dart
// a.dart
final class SecureData {
  String _data;
  
  SecureData(this._data);
  
  String get data => _data;
}

// b.dart
import 'a.dart';

// 可以实例化
var secure = SecureData('secret');

// 错误: 不能继承 final 类
// class ExtendedSecureData extends SecureData { }

// 错误: 不能实现 final 类
// class MockSecureData implements SecureData { }
```

### 6.5 sealed 修饰符

密封类用于创建已知的、可穷举的子类型集合，支持穷尽性检查。

```dart
// 所有子类必须在同一个库中
sealed class Shape {}

class Circle extends Shape {
  final double radius;
  Circle(this.radius);
}

class Rectangle extends Shape {
  final double width;
  final double height;
  Rectangle(this.width, this.height);
}

class Triangle extends Shape {
  final double a, b, c;
  Triangle(this.a, this.b, this.c);
}

// 穷尽性检查
String describeShape(Shape shape) {
  return switch (shape) {
    Circle(radius: var r) => 'Circle with radius $r',
    Rectangle(width: var w, height: var h) => 'Rectangle ${w}x${h}',
    Triangle(a: var a, b: var b, c: var c) => 'Triangle with sides $a, $b, $c',
  };
}

void main() {
  print(describeShape(Circle(5)));
  print(describeShape(Rectangle(4, 6)));
}
```

**Dart Tips 语法小贴士**

sealed 与 final 的区别

- `sealed`：允许在同一库中创建子类，支持穷尽性检查
- `final`：完全禁止子类型化，提供最严格的封装

选择建议：
- 需要穷尽性检查时使用 `sealed`
- 需要完全封装的 API 时使用 `final`

## 第7章 扩展（Extension）

扩展允许为现有类添加新功能，而无需继承该类或修改其源代码。

### 7.1 基本扩展

```dart
extension StringExtension on String {
  // 添加方法
  String reverse() {
    return split('').reversed.join('');
  }
  
  // 添加 Getter
  bool get isPalindrome {
    return this == reverse();
  }
  
  // 添加方法
  int wordCount() {
    return trim().split(RegExp(r'\s+')).length;
  }
  
  // 重载运算符
  String operator *(int times) {
    return List.filled(times, this).join();
  }
}

void main() {
  print('Hello'.reverse());        // 输出: olleH
  print('radar'.isPalindrome);     // 输出: true
  print('Hello Dart World'.wordCount());  // 输出: 3
  print('Hi' * 3);                 // 输出: HiHiHi
}
```

### 7.2 命名扩展

为扩展命名可以显式调用，解决 API 冲突。

```dart
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }
  
  double parseDouble() {
    return double.parse(this);
  }
}

void main() {
  print('42'.parseInt());      // 输出: 42
  print('3.14'.parseDouble()); // 输出: 3.14
  
  // 显式调用
  print(NumberParsing('100').parseInt());  // 输出: 100
}
```

### 7.3 泛型扩展

```dart
extension ListExtension<T> on List<T> {
  // 获取中间元素
  T? get middle {
    if (isEmpty) return null;
    return this[length ~/ 2];
  }
  
  // 分割列表
  List<List<T>> split(int at) {
    return [sublist(0, at), sublist(at)];
  }
  
  // 打乱列表
  List<T> shuffleCopy() {
    var copy = [...this];
    copy.shuffle();
    return copy;
  }
}

extension NumListExtension<T extends num> on List<T> {
  // 计算平均值
  double get average {
    if (isEmpty) return 0;
    return reduce((a, b) => (a + b) as T) / length;
  }
  
  // 计算总和
  T get sum => reduce((a, b) => (a + b) as T);
}

void main() {
  var numbers = [1, 2, 3, 4, 5];
  print(numbers.middle);      // 输出: 3
  print(numbers.average);     // 输出: 3.0
  print(numbers.sum);         // 输出: 15
  
  var split = numbers.split(2);
  print(split);  // 输出: [[1, 2], [3, 4, 5]]
}
```

### 7.4 扩展的静态成员

```dart
extension DateTimeExtension on DateTime {
  // 实例成员
  bool get isWeekend {
    return weekday == DateTime.saturday || weekday == DateTime.sunday;
  }
  
  // 静态成员
  static DateTime nowUtc() => DateTime.now().toUtc();
  
  static DateTime fromTimestamp(int timestamp) {
    return DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
  }
}

void main() {
  var now = DateTime.now();
  print(now.isWeekend);
  
  var utc = DateTimeExtension.nowUtc();
  print(utc);
}
```

### 7.5 扩展类型（Extension Type）

Dart 3.0 引入了扩展类型，为现有类型提供不同的接口，零运行时开销。

```dart
// 定义扩展类型
extension type Id(int value) {
  // 隐藏底层类型的方法，只暴露特定功能
  bool get isValid => value > 0;
  
  @override
  String toString() => 'Id($value)';
}

// 带命名构造函数的扩展类型
extension type NumberE(int value) {
  NumberE.zero() : value = 0;
  NumberE.one() : value = 1;
  
  NumberE operator +(NumberE other) => NumberE(value + other.value);
  
  bool get isEven => value.isEven;
}

// 实现接口的扩展类型
extension type Sequence<T>(List<T> _) implements Iterable<T> {
  // 继承 Iterable 的所有方法
}

void main() {
  var id = Id(42);
  print(id.isValid);  // 输出: true
  print(id);          // 输出: Id(42)
  
  // id.isEven;  // 错误: Id 没有 isEven 方法
  
  var num = NumberE(10);
  print(num.isEven);  // 输出: true
  
  var seq = Sequence<int>([1, 2, 3]);
  print(seq.length);  // 输出: 3
  print(seq.toList());  // 输出: [1, 2, 3]
}
```

**Flutter 框架小知识**

扩展类型在 Flutter 中的应用

扩展类型特别适合为底层类型（如 `int`、`String`）创建类型安全的包装，用于表示特定的业务概念。

```dart
// 用户 ID 类型
extension type UserId(int value) {
  bool get isValid => value > 0;
}

// 订单 ID 类型
extension type OrderId(String value) {
  bool get isValid => value.isNotEmpty && value.startsWith('ORD-');
}

// 防止不同类型混淆
void processUser(UserId userId) { }
void processOrder(OrderId orderId) { }

void main() {
  var userId = UserId(123);
  var orderId = OrderId('ORD-456');
  
  processUser(userId);    // 正确
  // processUser(orderId); // 错误: 类型不匹配
}
```

## 第8章 实战应用示例

### 8.1 完整的领域模型

```dart
// 值对象
extension type Email(String value) {
  bool get isValid {
    return RegExp(r'^[\w\.-]+@[\w\.-]+\.\w+$').hasMatch(value);
  }
}

// 实体
class User {
  final String id;
  String name;
  Email email;
  DateTime createdAt;
  
  User({
    required this.id,
    required this.name,
    required this.email,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now();
  
  factory User.create({required String name, required Email email}) {
    return User(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: name,
      email: email,
    );
  }
  
  void updateEmail(Email newEmail) {
    if (!newEmail.isValid) {
      throw ArgumentError('Invalid email');
    }
    email = newEmail;
  }
  
  @override
  String toString() => 'User(id: $id, name: $name, email: $email)';
}

// 仓储接口
abstract interface class UserRepository {
  User? findById(String id);
  List<User> findAll();
  void save(User user);
  void delete(String id);
}

// 仓储实现
class InMemoryUserRepository implements UserRepository {
  final Map<String, User> _users = {};
  
  @override
  User? findById(String id) => _users[id];
  
  @override
  List<User> findAll() => _users.values.toList();
  
  @override
  void save(User user) => _users[user.id] = user;
  
  @override
  void delete(String id) => _users.remove(id);
}

void main() {
  var repository = InMemoryUserRepository();
  
  var user = User.create(
    name: 'Alice',
    email: Email('alice@example.com'),
  );
  
  repository.save(user);
  
  var found = repository.findById(user.id);
  print(found);
}
```

### 8.2 Flutter 状态管理模型

```dart
// 状态基类
sealed class AppState {
  const AppState();
}

class LoadingState extends AppState {
  const LoadingState();
}

class SuccessState<T> extends AppState {
  final T data;
  const SuccessState(this.data);
}

class ErrorState extends AppState {
  final String message;
  const ErrorState(this.message);
}

// 状态处理器
extension AppStateExtension on AppState {
  R when<R>({
    required R Function() loading,
    required R Function(dynamic data) success,
    required R Function(String message) error,
  }) {
    return switch (this) {
      LoadingState() => loading(),
      SuccessState(data: var d) => success(d),
      ErrorState(message: var m) => error(m),
    };
  }
}

// 使用示例
Widget buildStateWidget(AppState state) {
  return state.when(
    loading: () => CircularProgressIndicator(),
    success: (data) => Text('Data: $data'),
    error: (message) => Text('Error: $message', style: TextStyle(color: Colors.red)),
  );
}
```

## 附录：类相关速查表

| 特性 | 关键字/语法 | 说明 |
|------|------------|------|
| 类定义 | `class Name {}` | 定义一个类 |
| 继承 | `extends` | 单继承 |
| 实现接口 | `implements` | 实现一个或多个接口 |
| 混入 | `with` | 混入一个或多个 Mixin |
| 抽象类 | `abstract class` | 不能被实例化 |
| 常量构造函数 | `const` | 编译时常量 |
| 工厂构造函数 | `factory` | 自定义实例创建逻辑 |
| 命名构造函数 | `Class.name()` | 多个构造函数 |
| Getter | `Type get name => value` | 计算属性 |
| Setter | `set name(Type value) {}` | 属性赋值控制 |
| 静态成员 | `static` | 属于类而非实例 |
| 私有成员 | `_name` | 库内私有 |
| 方法重写 | `@override` | 重写父类方法 |
| 抽象方法 | 无方法体 | 子类必须实现 |
| Mixin | `mixin Name {}` | 代码复用 |
| Mixin 限制 | `mixin Name on Type {}` | 限制使用范围 |
| 扩展 | `extension Name on Type {}` | 为现有类添加功能 |
| 扩展类型 | `extension type Name(Type value) {}` | 零开销抽象 |
| base 类 | `base class` | 强制继承 |
| interface 类 | `interface class` | 仅可实现 |
| final 类 | `final class` | 禁止子类型化 |
| sealed 类 | `sealed class` | 穷尽性检查 |

---

本文档详细介绍了 Dart 语言的类系统，从基础的类定义、属性、方法，到高级的继承、抽象类、接口、Mixin、扩展以及 Dart 3.0 引入的类修饰符和扩展类型等新特性。掌握这些内容将帮助你编写出更加优雅、可维护的 Dart 代码，特别是在 Flutter 开发中能够更好地组织应用架构。
