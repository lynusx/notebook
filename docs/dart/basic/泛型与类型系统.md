# Dart 语言泛型与类型系统详解

泛型（Generics）是 Dart 类型系统的核心特性之一，它允许开发者编写类型安全、可复用的代码，而无需为每种类型重复编写相同的逻辑。泛型通过类型参数化，使得类、接口和方法能够适用于多种数据类型，同时保持编译时的类型检查。本章将系统且全面地介绍 Dart 语言的泛型系统，包括泛型类、泛型方法、类型约束、型变（协变与逆变）、类型推断以及 Dart 3.0 引入的模式匹配和穷尽性检查等新特性，配合大量实例代码，帮助读者深入理解并熟练运用 Dart 的泛型与类型系统。

## 第1章 泛型基础

### 1.1 为什么使用泛型

泛型的主要优势在于类型安全和代码复用。在没有泛型的情况下，开发者通常使用 `dynamic` 或 `Object` 类型来处理多种数据类型，但这会失去编译时的类型检查。

```dart
// 不使用泛型：类型不安全
class IntBox {
  int value;
  IntBox(this.value);
}

class StringBox {
  String value;
  StringBox(this.value);
}

// 需要为每种类型创建单独的类
// 代码重复，难以维护

// 使用 dynamic：失去类型检查
class DynamicBox {
  dynamic value;
  DynamicBox(this.value);
}

void main() {
  var box = DynamicBox(42);
  box.value = 'Hello';  // 运行时才能发现类型错误
  // print(box.value.length);  // 运行时错误: int 没有 length 属性
}
```

使用泛型可以解决上述问题：

```dart
// 使用泛型：类型安全且可复用
class Box<T> {
  T value;
  Box(this.value);
  
  T getValue() => value;
  void setValue(T newValue) => value = newValue;
}

void main() {
  // 整数盒子
  var intBox = Box<int>(42);
  print(intBox.getValue());  // 输出: 42
  // intBox.setValue('Hello');  // 编译错误: 类型不匹配
  
  // 字符串盒子
  var stringBox = Box<String>('Hello');
  print(stringBox.getValue());  // 输出: Hello
  
  // 类型推断
  var inferredBox = Box(3.14);  // 推断为 Box<double>
  print(inferredBox.getValue());  // 输出: 3.14
}
```

### 1.2 泛型类

泛型类通过在类名后添加类型参数 `<T>` 来定义，类型参数可以在类的属性、方法和构造函数中使用。

#### 1.2.1 基本泛型类

```dart
// 泛型类定义
class Container<T> {
  T _item;
  
  Container(this._item);
  
  T get item => _item;
  set item(T value) => _item = value;
  
  bool isEmpty() => _item == null;
}

// 多个类型参数
class Pair<K, V> {
  final K key;
  final V value;
  
  Pair(this.key, this.value);
  
  @override
  String toString() => 'Pair($key: $value)';
}

void main() {
  // 单类型参数
  var intContainer = Container<int>(100);
  print(intContainer.item);  // 输出: 100
  
  // 多类型参数
  var nameAge = Pair<String, int>('Alice', 25);
  print(nameAge);  // 输出: Pair(Alice: 25)
  
  var coordinates = Pair<double, double>(37.7749, -122.4194);
  print(coordinates);  // 输出: Pair(37.7749: -122.4194)
}
```

#### 1.2.2 泛型集合类

Dart 的核心集合类都是泛型的，这是泛型最常见的应用场景。

```dart
void main() {
  // List<T>
  List<int> numbers = [1, 2, 3, 4, 5];
  List<String> names = ['Alice', 'Bob', 'Charlie'];
  
  // Map<K, V>
  Map<String, int> scores = {
    'Alice': 90,
    'Bob': 85,
    'Charlie': 92,
  };
  
  // Set<T>
  Set<String> uniqueNames = {'Alice', 'Bob', 'Alice'};  // 自动去重
  print(uniqueNames);  // 输出: {Alice, Bob}
  
  // 嵌套泛型
  Map<String, List<int>> gradeBook = {
    'Alice': [90, 85, 92],
    'Bob': [78, 82, 88],
  };
  
  // 泛型方法调用
  var doubled = numbers.map((n) => n * 2).toList();
  print(doubled);  // 输出: [2, 4, 6, 8, 10]
}
```

#### 1.2.3 泛型构造函数

泛型类可以有多个构造函数，包括命名构造函数。

```dart
class Cache<K, V> {
  final Map<K, V> _storage = {};
  
  // 默认构造函数
  Cache();
  
  // 命名构造函数：从 Map 创建
  Cache.fromMap(Map<K, V> initial) {
    _storage.addAll(initial);
  }
  
  // 命名构造函数：带容量限制
  Cache.withCapacity(int capacity);
  
  void put(K key, V value) => _storage[key] = value;
  V? get(K key) => _storage[key];
  bool containsKey(K key) => _storage.containsKey(key);
  
  Iterable<K> get keys => _storage.keys;
  Iterable<V> get values => _storage.values;
}

void main() {
  var cache = Cache<String, int>();
  cache.put('age', 25);
  print(cache.get('age'));  // 输出: 25
  
  var fromMap = Cache<String, String>.fromMap({
    'name': 'Alice',
    'city': 'Beijing',
  });
  print(fromMap.get('name'));  // 输出: Alice
}
```

### 1.3 泛型方法

泛型方法允许在方法级别定义类型参数，这些类型参数只在方法内部有效。

#### 1.3.1 基本泛型方法

```dart
class Utils {
  // 泛型静态方法
  static T? firstOrNull<T>(List<T> list) {
    return list.isEmpty ? null : list.first;
  }
  
  // 泛型实例方法
  T identity<T>(T value) => value;
  
  // 交换两个值
  static void swap<T>(List<T> list, int i, int j) {
    var temp = list[i];
    list[i] = list[j];
    list[j] = temp;
  }
}

// 独立泛型函数
T? findFirst<T>(List<T> list, bool Function(T) predicate) {
  for (var item in list) {
    if (predicate(item)) return item;
  }
  return null;
}

void main() {
  // 静态泛型方法
  var numbers = [1, 2, 3];
  print(Utils.firstOrNull(numbers));  // 输出: 1
  print(Utils.firstOrNull<int>([]));  // 输出: null
  
  // 泛型函数
  var names = ['Alice', 'Bob', 'Charlie'];
  var found = findFirst(names, (name) => name.startsWith('B'));
  print(found);  // 输出: Bob
  
  // 交换
  var list = [1, 2, 3];
  Utils.swap(list, 0, 2);
  print(list);  // 输出: [3, 2, 1]
}
```

#### 1.3.2 泛型方法与类泛型参数的关系

```dart
class Processor<T> {
  final T data;
  
  Processor(this.data);
  
  // 使用类的泛型参数
  T process() => data;
  
  // 定义自己的泛型参数（与类的泛型参数无关）
  R transform<R>(R Function(T) converter) {
    return converter(data);
  }
  
  // 同时使用类和方法的泛型参数
  S combine<S>(Processor<S> other, S Function(T, S) combiner) {
    return combiner(data, other.data);
  }
}

void main() {
  var processor = Processor<int>(42);
  
  // 使用类泛型
  print(processor.process());  // 输出: 42
  
  // 使用方法泛型
  var stringResult = processor.transform((n) => 'Number: $n');
  print(stringResult);  // 输出: Number: 42
  
  // 组合不同类型
  var intProcessor = Processor<int>(10);
  var stringProcessor = Processor<String>('Hello');
  // var combined = intProcessor.combine(stringProcessor, (a, b) => '$a$b');
  // print(combined);  // 输出: 10Hello
}
```

**Dart Tips 语法小贴士**

泛型类型推断

Dart 的类型推断系统通常能够自动推断泛型类型参数，但在某些情况下需要显式指定：

```dart
// 类型推断成功
var list = [1, 2, 3];  // List<int>
var box = Box('hello');  // Box<String>

// 需要显式指定类型的情况
var emptyList = <int>[];  // 空列表需要指定类型
var emptyMap = <String, int>{};  // 空 Map 需要指定类型

// 复杂表达式可能需要显式类型
T identity<T>(T value) => value;
var result = identity<String>('test');  // 显式指定 T 为 String
```

## 第2章 类型约束

类型约束（Type Constraints）允许限制泛型类型参数的范围，确保类型参数满足特定的条件，如实现某个接口或继承某个类。

### 2.1 基本类型约束

使用 `extends` 关键字对泛型类型参数进行约束。

```dart
// 约束 T 必须是 num 或其子类
class NumberBox<T extends num> {
  T value;
  NumberBox(this.value);
  
  // 由于 T 是 num 的子类，可以使用 num 的方法
  bool get isPositive => value > 0;
  bool get isInteger => value is int;
  double get asDouble => value.toDouble();
}

// 约束 T 必须实现 Comparable 接口
T max<T extends Comparable<T>>(T a, T b) {
  return a.compareTo(b) > 0 ? a : b;
}

void main() {
  // 合法使用
  var intBox = NumberBox<int>(42);
  print(intBox.isPositive);  // 输出: true
  
  var doubleBox = NumberBox<double>(3.14);
  print(doubleBox.asDouble);  // 输出: 3.14
  
  // var stringBox = NumberBox<String>('hello');  // 错误: String 不是 num 的子类
  
  // 使用 Comparable 约束
  print(max(10, 20));  // 输出: 20
  print(max('apple', 'banana'));  // 输出: banana
  // print(max(DateTime.now(), DateTime.now()));  // DateTime 实现了 Comparable
}
```

### 2.2 多重约束

Dart 不支持直接在类型参数上使用多个 `extends` 约束，但可以通过接口组合实现类似效果。

```dart
// 定义组合接口
abstract class Serializable {
  String toJson();
}

abstract class Cloneable<T> {
  T clone();
}

// 实现组合接口的类
class Person implements Serializable, Cloneable<Person> {
  final String name;
  final int age;
  
  Person(this.name, this.age);
  
  @override
  String toJson() => '{"name":"$name","age":$age}';
  
  @override
  Person clone() => Person(name, age);
}

// 使用组合接口作为约束
class Repository<T extends Serializable> {
  final List<T> _items = [];
  
  void add(T item) => _items.add(item);
  
  List<String> toJsonList() {
    return _items.map((item) => item.toJson()).toList();
  }
}

void main() {
  var repo = Repository<Person>();
  repo.add(Person('Alice', 25));
  repo.add(Person('Bob', 30));
  
  print(repo.toJsonList());
  // 输出: [{"name":"Alice","age":25}, {"name":"Bob","age":30}]
}
```

### 2.3 递归类型约束

泛型类型参数可以引用自身，实现递归类型约束。

```dart
// 约束 T 必须是 Comparable<T>（自身类型）
class SortedList<T extends Comparable<T>> {
  final List<T> _items = [];
  
  void add(T item) {
    _items.add(item);
    _items.sort();
  }
  
  List<T> get items => List.unmodifiable(_items);
}

// 实现 Comparable 的类
class Student implements Comparable<Student> {
  final String name;
  final int score;
  
  Student(this.name, this.score);
  
  @override
  int compareTo(Student other) => score.compareTo(other.score);
  
  @override
  String toString() => '$name($score)';
}

void main() {
  var sortedList = SortedList<Student>();
  sortedList.add(Student('Alice', 85));
  sortedList.add(Student('Bob', 92));
  sortedList.add(Student('Charlie', 78));
  
  print(sortedList.items);  // 输出: [Charlie(78), Alice(85), Bob(92)]
}
```

### 2.4 方法级别的类型约束

类型约束可以应用于泛型方法，而不影响类的其他部分。

```dart
class DataProcessor {
  // 方法级别的类型约束
  T processNumber<T extends num>(T value) {
    print('Processing: $value');
    return value;
  }
  
  // 多个类型参数，各自有不同的约束
  R convert<T extends num, R extends String>(T value) {
    return value.toString() as R;
  }
  
  // 约束方法参数之间的关系
  T sum<T extends num>(List<T> values) {
    num total = 0;
    for (var v in values) {
      total += v;
    }
    return total as T;
  }
}

void main() {
  var processor = DataProcessor();
  
  processor.processNumber(42);  // 输出: Processing: 42
  processor.processNumber(3.14);  // 输出: Processing: 3.14
  // processor.processNumber('hello');  // 错误: String 不是 num
  
  var total = processor.sum([1, 2, 3, 4, 5]);
  print(total);  // 输出: 15
}
```

## 第3章 型变（Variance）

型变（Variance）描述了泛型类型参数在类型层次关系中的行为方式。Dart 支持三种型变：协变（Covariance）、逆变（Contravariance）和不变（Invariance）。

### 3.1 不变（Invariance）

默认情况下，Dart 的泛型类型是不变的，即 `List<Cat>` 不是 `List<Animal>` 的子类型，反之亦然。

```dart
class Animal {
  void speak() => print('Animal speaks');
}

class Cat extends Animal {
  void meow() => print('Meow');
}

class Dog extends Animal {
  void bark() => print('Woof');
}

void main() {
  List<Cat> cats = [Cat(), Cat()];
  // List<Animal> animals = cats;  // 错误: List<Cat> 不是 List<Animal> 的子类型
  
  // 原因: 如果允许上述赋值，下面的代码会导致运行时错误
  // animals.add(Dog());  // 这在 List<Cat> 中是非法的
  
  // 正确做法: 使用通配符类型或协变
  List<Animal> animals = [...cats];  // 创建新列表
  animals.add(Dog());
  
  for (var animal in animals) {
    animal.speak();
  }
}
```

### 3.2 协变（Covariance）

协变意味着如果 `Cat` 是 `Animal` 的子类型，那么 `Producer<Cat>` 是 `Producer<Animal>` 的子类型。在 Dart 中，返回值位置使用泛型类型参数时，可以安全地使用协变。

```dart
// 协变示例：只生产（返回）T，不消费（接收）T
abstract class Producer<T> {
  T produce();
}

class AnimalProducer implements Producer<Animal> {
  @override
  Animal produce() => Animal();
}

class CatProducer implements Producer<Cat> {
  @override
  Cat produce() => Cat();
}

void useProducer(Producer<Animal> producer) {
  var animal = producer.produce();
  animal.speak();
}

void main() {
  // CatProducer 可以当作 Producer<Animal> 使用
  useProducer(CatProducer());  // 安全，因为 Cat 是 Animal
  
  // 这是因为 CatProducer 返回的 Cat 可以安全地当作 Animal 使用
}
```

### 3.3 逆变（Contravariance）

逆变意味着如果 `Cat` 是 `Animal` 的子类型，那么 `Consumer<Animal>` 是 `Consumer<Cat>` 的子类型。在 Dart 中，参数位置使用泛型类型参数时，可以安全地使用逆变。

```dart
// 逆变示例：只消费（接收）T，不生产（返回）T
abstract class Consumer<T> {
  void consume(T item);
}

class AnimalConsumer implements Consumer<Animal> {
  @override
  void consume(Animal animal) {
    animal.speak();
  }
}

class CatConsumer implements Consumer<Cat> {
  @override
  void consume(Cat cat) {
    cat.meow();
  }
}

void useConsumer(Consumer<Cat> consumer) {
  consumer.consume(Cat());
}

void main() {
  // AnimalConsumer 可以当作 Consumer<Cat> 使用
  useConsumer(AnimalConsumer());  // 安全，因为 AnimalConsumer 可以处理任何 Animal
  
  // 这是因为 AnimalConsumer 可以处理 Cat（Cat 是 Animal）
}
```

### 3.4 covariant 关键字

Dart 提供了 `covariant` 关键字，允许在子类中收紧（使用更具体的子类型）方法参数的类型。这实际上是一种协变行为，但会绕过静态类型检查，改为运行时检查。

```dart
class Animal {
  void chase(Animal other) {
    print('Animal chasing Animal');
  }
}

class Mouse extends Animal {}

class Cat extends Animal {
  // 使用 covariant 收紧参数类型
  @override
  void chase(covariant Mouse mouse) {
    print('Cat chasing Mouse');
    mouse;  // 可以确定是 Mouse 类型
  }
}

void main() {
  Animal animal = Cat();
  
  // 静态检查通过，因为参数声明为 Animal
  // 但运行时检查会失败，因为 Cat.chase 期望 Mouse
  // animal.chase(Animal());  // 运行时错误: 期望 Mouse，得到 Animal
  
  // 正确用法
  animal.chase(Mouse());  // 输出: Cat chasing Mouse
  
  // 直接使用 Cat 类型
  Cat cat = Cat();
  cat.chase(Mouse());  // 输出: Cat chasing Mouse
  // cat.chase(Animal());  // 编译错误: 期望 Mouse
}
```

**Dart Tips 语法小贴士**

covariant 的使用注意事项

使用 `covariant` 关键字会绕过静态类型检查，改为运行时检查，这可能导致运行时错误。因此，只有在确实需要收紧参数类型时才使用，并且要确保调用方了解实际类型。

```dart
// 不推荐: 滥用 covariant
class Unsafe {
  void method(covariant String param) {}  // 危险
}

// 推荐: 仅在必要时使用
class Safe {
  void process(covariant SpecificType item) {
    // 明确知道 item 是 SpecificType
  }
}
```

### 3.5 型变的实际应用

```dart
// 协变: 只读集合
abstract class ReadOnlyList<out T> {
  T get(int index);
  int get length;
}

// 逆变: 只写集合
abstract class WriteOnlyList<in T> {
  void add(T item);
  void addAll(List<T> items);
}

// 不变: 读写集合
abstract class MutableList<T> implements ReadOnlyList<T>, WriteOnlyList<T> {
  void set(int index, T value);
}

// 注意: Dart 不直接支持 out/in 关键字，上述代码是概念性的
// 实际实现通过接口设计来模拟

// 实际的 Dart 实现
abstract class ImmutableList<T> {
  T operator [](int index);
  int get length;
  ImmutableList<T> sublist(int start, int end);
}

abstract class AppendableList<T> {
  void add(T item);
  void addAll(Iterable<T> items);
}

void printAll(ImmutableList<Animal> animals) {
  for (var i = 0; i < animals.length; i++) {
    print(animals[i]);
  }
}

void main() {
  // 由于协变，可以将 ImmutableList<Cat> 传递给需要 ImmutableList<Animal> 的函数
  // （如果实现正确的话）
}
```

## 第4章 类型推断

Dart 的类型推断系统能够自动推断变量、表达式和泛型类型参数的类型，减少类型注解的冗余。

### 4.1 变量类型推断

```dart
void main() {
  // 从初始值推断类型
  var name = 'Alice';  // String
  var age = 25;  // int
  var pi = 3.14159;  // double
  var isActive = true;  // bool
  
  // 从集合元素推断类型
  var numbers = [1, 2, 3];  // List<int>
  var mixed = [1, 'two', 3.0];  // List<Object>
  
  // 从 Map 条目推断类型
  var scores = {'Alice': 90, 'Bob': 85};  // Map<String, int>
  
  // 显式类型注解
  String explicitName = 'Bob';
  List<int> explicitNumbers = [];
  
  // 类型推断失败时使用 dynamic
  var emptyList = [];  // List<dynamic>
  var emptyMap = {};  // Map<dynamic, dynamic>
  
  // 显式指定泛型类型
  var typedList = <int>[];  // List<int>
  var typedMap = <String, int>{};  // Map<String, int>
}
```

### 4.2 泛型类型推断

```dart
T identity<T>(T value) => value;

T first<T>(List<T> list) => list.first;

T max<T extends Comparable<T>>(T a, T b) => 
  a.compareTo(b) > 0 ? a : b;

void main() {
  // 从参数推断泛型类型
  var result1 = identity('hello');  // T 推断为 String
  var result2 = identity(42);  // T 推断为 int
  
  // 从列表元素推断
  var firstInt = first([1, 2, 3]);  // T 推断为 int
  var firstString = first(['a', 'b']);  // T 推断为 String
  
  // 从参数类型推断约束
  var maxResult = max(10, 20);  // T 推断为 int
  // var maxError = max(10, '20');  // 错误: 类型不匹配
  
  // 显式指定泛型类型
  var explicit = identity<String>('test');
}
```

### 4.3 上下文类型推断

Dart 会根据上下文推断类型，特别是在函数参数和赋值操作中。

```dart
void processStrings(List<String> strings) {
  print(strings.join(', '));
}

T create<T>(T Function() factory) => factory();

void main() {
  // 从函数参数推断类型
  processStrings(['a', 'b', 'c']);  // 推断为 List<String>
  
  // 从返回值推断类型
  String name = create(() => 'Alice');  // T 推断为 String
  
  // 级联推断
  var list = [1, 2, 3]
    ..add(4)
    ..map((n) => n * 2)  // n 推断为 int
    ..where((n) => n > 2);  // n 推断为 int
  
  // 条件表达式推断
  var value = true ? 1 : 2;  // 推断为 int
  var mixed = true ? 1 : 2.0;  // 推断为 num
}
```

### 4.4 泛型方法调用的类型推断

```dart
class CollectionUtils {
  // 类型推断考虑所有参数
  static T fold<T>(List<T> list, T initial, T Function(T, T) combine) {
    var result = initial;
    for (var item in list) {
      result = combine(result, item);
    }
    return result;
  }
  
  // 从回调推断类型
  static List<R> map<T, R>(List<T> list, R Function(T) transform) {
    return list.map(transform).toList();
  }
}

void main() {
  // 从所有参数推断 T
  var sum = CollectionUtils.fold([1, 2, 3], 0, (a, b) => a + b);
  print(sum);  // 输出: 6
  
  // 从回调推断 R
  var strings = CollectionUtils.map([1, 2, 3], (n) => 'Number $n');
  print(strings);  // 输出: [Number 1, Number 2, Number 3]
  
  // 复杂推断
  var nested = CollectionUtils.map(
    [1, 2, 3],
    (n) => [n, n * 2],  // 推断 R 为 List<int>
  );
  print(nested);  // 输出: [[1, 2], [2, 4], [3, 6]]
}
```

## 第5章 模式匹配与穷尽性检查

Dart 3.0 引入了强大的模式匹配（Pattern Matching）功能，配合 `sealed` 类可以实现穷尽性检查（Exhaustiveness Checking）。

### 5.1 基本模式匹配

```dart
void main() {
  // 常量模式
  var value = 42;
  switch (value) {
    case 1:
      print('One');
    case 42:
      print('Forty-two');  // 匹配
    default:
      print('Other');
  }
  
  // 变量模式
  var (a, b) = (1, 2);
  print('a=$a, b=$b');  // 输出: a=1, b=2
  
  // 通配符模式
  var (x, _) = (10, 20);  // 忽略第二个值
  print('x=$x');  // 输出: x=10
  
  // 列表模式
  var [first, second, ...rest] = [1, 2, 3, 4, 5];
  print('first=$first, second=$second, rest=$rest');
  // 输出: first=1, second=2, rest=[3, 4, 5]
  
  // Map 模式
  var {'name': name, 'age': age} = {'name': 'Alice', 'age': 25};
  print('name=$name, age=$age');  // 输出: name=Alice, age=25
  
  // 记录模式
  var (name: n, age: a) = (name: 'Bob', age: 30);
  print('name=$n, age=$a');  // 输出: name=Bob, age=30
}
```

### 5.2 sealed 类与穷尽性检查

`sealed` 类用于创建已知的、可穷举的子类型集合，编译器可以在 `switch` 表达式中进行穷尽性检查。

```dart
// 定义 sealed 类层次结构
sealed class Shape {}

class Square extends Shape {
  final double side;
  Square(this.side);
}

class Circle extends Shape {
  final double radius;
  Circle(this.radius);
}

class Triangle extends Shape {
  final double a, b, c;
  Triangle(this.a, this.b, this.c);
}

// 穷尽性检查：必须处理所有子类型
double calculateArea(Shape shape) {
  return switch (shape) {
    Square(side: var s) => s * s,
    Circle(radius: var r) => 3.14159 * r * r,
    Triangle(a: var a, b: var b, c: var c) => _triangleArea(a, b, c),
  };
}

double _triangleArea(double a, double b, double c) {
  var s = (a + b + c) / 2;
  return (s * (s - a) * (s - b) * (s - c)).sqrt();
}

// 扩展方法
extension on double {
  double sqrt() => this <= 0 ? 0 : _sqrt(this);
  
  double _sqrt(double x) {
    var guess = x / 2;
    for (var i = 0; i < 10; i++) {
      guess = (guess + x / guess) / 2;
    }
    return guess;
  }
}

void main() {
  var square = Square(5);
  var circle = Circle(3);
  var triangle = Triangle(3, 4, 5);
  
  print('Square area: ${calculateArea(square)}');  // 输出: 25
  print('Circle area: ${calculateArea(circle)}');  // 输出: 28.27431
  print('Triangle area: ${calculateArea(triangle)}');  // 输出: 6
}
```

### 5.3 守卫子句（Guard Clause）

使用 `when` 关键字在模式匹配中添加条件守卫。

```dart
String describeNumber(int n) {
  return switch (n) {
    case 0 => 'Zero',
    case > 0 && < 10 => 'Single digit positive',
    case >= 10 && < 100 => 'Double digit positive',
    case > 100 when n.isEven => 'Large even positive',
    case > 100 => 'Large odd positive',
    case < 0 when n.abs() < 10 => 'Single digit negative',
    case < 0 => 'Negative',
  };
}

String classifyAge(int age) {
  return switch (age) {
    case < 0 => 'Invalid',
    case < 13 => 'Child',
    case < 20 => 'Teenager',
    case < 65 => 'Adult',
    case _ => 'Senior',  // 通配符匹配剩余情况
  };
}

void main() {
  print(describeNumber(5));  // 输出: Single digit positive
  print(describeNumber(150));  // 输出: Large even positive
  print(describeNumber(-5));  // 输出: Single digit negative
  
  print(classifyAge(10));  // 输出: Child
  print(classifyAge(25));  // 输出: Adult
  print(classifyAge(70));  // 输出: Senior
}
```

### 5.4 代数数据类型（ADT）风格

结合 `sealed` 类和记录类型，可以实现类似函数式语言中的代数数据类型。

```dart
// 定义结果类型（类似 Rust 的 Result 或 Haskell 的 Either）
sealed class Result<T, E> {}

class Success<T, E> extends Result<T, E> {
  final T value;
  Success(this.value);
}

class Failure<T, E> extends Result<T, E> {
  final E error;
  Failure(this.error);
}

// 使用 Result 类型
Result<int, String> divide(int a, int b) {
  if (b == 0) {
    return Failure('Division by zero');
  }
  return Success(a ~/ b);
}

// 穷尽处理所有情况
String handleResult(Result<int, String> result) {
  return switch (result) {
    Success(value: var v) => 'Success: $v',
    Failure(error: var e) => 'Error: $e',
  };
}

// 可选类型（类似 Rust 的 Option）
sealed class Option<T> {}

class Some<T> extends Option<T> {
  final T value;
  Some(this.value);
}

class None<T> extends Option<T> {}

// 使用 Option 类型
Option<int> findIndex(List<String> list, String target) {
  for (var i = 0; i < list.length; i++) {
    if (list[i] == target) return Some(i);
  }
  return None();
}

T? unwrap<T>(Option<T> option) {
  return switch (option) {
    Some(value: var v) => v,
    None() => null,
  };
}

void main() {
  var result1 = divide(10, 2);
  print(handleResult(result1));  // 输出: Success: 5
  
  var result2 = divide(10, 0);
  print(handleResult(result2));  // 输出: Error: Division by zero
  
  var names = ['Alice', 'Bob', 'Charlie'];
  var index = findIndex(names, 'Bob');
  print(unwrap(index));  // 输出: 1
  
  var notFound = findIndex(names, 'David');
  print(unwrap(notFound));  // 输出: null
}
```

**Flutter 框架小知识**

模式匹配在 Flutter 状态管理中的应用

模式匹配特别适合处理 Flutter 中的状态管理，配合 `sealed` 类可以实现类型安全的状态处理。

```dart
// 定义 UI 状态
sealed class UiState<T> {}

class Loading<T> extends UiState<T> {}

class Success<T> extends UiState<T> {
  final T data;
  Success(this.data);
}

class Error<T> extends UiState<T> {
  final String message;
  Error(this.message);
}

// 在 Widget 中使用
Widget buildState<T>(UiState<T> state) {
  return switch (state) {
    Loading() => CircularProgressIndicator(),
    Success(data: var data) => Text('Data: $data'),
    Error(message: var msg) => Text('Error: $msg', style: TextStyle(color: Colors.red)),
  };
}
```

## 第6章 高级泛型技巧

### 6.1 泛型单例模式

```dart
// 泛型单例工厂
class Singleton<T> {
  static final Map<Type, Object> _instances = {};
  
  factory Singleton.get(T Function() factory) {
    return _instances.putIfAbsent(T, () => factory()) as Singleton<T>;
  }
  
  Singleton._internal();
}

// 更实用的泛型服务定位器
class ServiceLocator {
  static final Map<Type, Object> _services = {};
  static final Map<Type, Function> _factories = {};
  
  static void register<T>(T Function() factory) {
    _factories[T] = factory;
  }
  
  static void registerSingleton<T>(T instance) {
    _services[T] = instance;
  }
  
  static T get<T>() {
    if (_services.containsKey(T)) {
      return _services[T] as T;
    }
    if (_factories.containsKey(T)) {
      var instance = _factories[T]!();
      _services[T] = instance;
      return instance as T;
    }
    throw Exception('Service $T not registered');
  }
}

// 使用示例
class DatabaseService {
  void query(String sql) => print('Querying: $sql');
}

class ApiService {
  void fetch(String url) => print('Fetching: $url');
}

void main() {
  ServiceLocator.register<DatabaseService>(() => DatabaseService());
  ServiceLocator.register<ApiService>(() => ApiService());
  
  var db = ServiceLocator.get<DatabaseService>();
  db.query('SELECT * FROM users');
  
  var api = ServiceLocator.get<ApiService>();
  api.fetch('/api/users');
}
```

### 6.2 泛型 Builder 模式

```dart
// 泛型构建器
class RequestBuilder<T> {
  String? _url;
  Map<String, String> _headers = {};
  Map<String, dynamic> _body = {};
  T Function(dynamic)? _parser;
  
  RequestBuilder<T> url(String url) {
    _url = url;
    return this;
  }
  
  RequestBuilder<T> header(String key, String value) {
    _headers[key] = value;
    return this;
  }
  
  RequestBuilder<T> bodyField(String key, dynamic value) {
    _body[key] = value;
    return this;
  }
  
  RequestBuilder<T> parser(T Function(dynamic) parser) {
    _parser = parser;
    return this;
  }
  
  Future<T> execute() async {
    if (_url == null) throw Exception('URL not set');
    if (_parser == null) throw Exception('Parser not set');
    
    // 模拟 HTTP 请求
    print('Request to: $_url');
    print('Headers: $_headers');
    print('Body: $_body');
    
    // 模拟响应
    var response = {'data': 'response data'};
    return _parser!(response);
  }
}

// 使用示例
class User {
  final String name;
  final int age;
  User(this.name, this.age);
  
  factory User.fromJson(Map<String, dynamic> json) {
    return User(json['name'], json['age']);
  }
}

void main() async {
  var user = await RequestBuilder<User>()
    .url('https://api.example.com/users/1')
    .header('Authorization', 'Bearer token')
    .header('Content-Type', 'application/json')
    .parser((json) => User.fromJson(json['data']))
    .execute();
  
  print('User: ${user.name}, ${user.age}');
}
```

### 6.3 类型安全的 Event Bus

```dart
import 'dart:async';

// 类型安全的事件总线
class TypedEventBus {
  final Map<Type, StreamController<dynamic>> _controllers = {};
  final Map<Type, List<StreamSubscription>> _subscriptions = {};
  
  StreamController<T> _getController<T>() {
    return _controllers.putIfAbsent(
      T,
      () => StreamController<T>.broadcast(),
    ) as StreamController<T>;
  }
  
  // 发送事件
  void emit<T>(T event) {
    _getController<T>().add(event);
  }
  
  // 监听事件
  StreamSubscription<T> on<T>(void Function(T) handler) {
    var subscription = _getController<T>().stream.listen(handler);
    _subscriptions.putIfAbsent(T, () => []).add(subscription);
    return subscription;
  }
  
  // 只监听一次
  void once<T>(void Function(T) handler) {
    late StreamSubscription<T> sub;
    sub = _getController<T>().stream.listen((event) {
      handler(event);
      sub.cancel();
    });
  }
  
  // 取消所有订阅
  void off<T>() {
    _subscriptions[T]?.forEach((sub) => sub.cancel());
    _subscriptions.remove(T);
  }
  
  // 销毁
  void dispose() {
    _controllers.values.forEach((c) => c.close());
    _controllers.clear();
    _subscriptions.clear();
  }
}

// 定义事件类型
class UserLoggedIn {
  final String userId;
  final String username;
  UserLoggedIn(this.userId, this.username);
}

class UserLoggedOut {
  final String userId;
  UserLoggedOut(this.userId);
}

class DataUpdated<T> {
  final T data;
  DataUpdated(this.data);
}

void main() {
  var eventBus = TypedEventBus();
  
  // 监听特定类型事件
  eventBus.on<UserLoggedIn>((event) {
    print('User logged in: ${event.username}');
  });
  
  eventBus.on<DataUpdated<String>>((event) {
    print('Data updated: ${event.data}');
  });
  
  // 发送事件
  eventBus.emit(UserLoggedIn('123', 'Alice'));
  eventBus.emit(DataUpdated<String>('New data'));
  
  // 不会触发 UserLoggedIn 监听器
  eventBus.emit(UserLoggedOut('123'));
  
  eventBus.dispose();
}
```

### 6.4 泛型状态机

```dart
// 状态机状态接口
abstract class State<S extends State<S, E>, E extends Event<E, S>> {
  S? onEvent(E event);
}

abstract class Event<E extends Event<E, S>, S extends State<S, E>> {}

// 具体状态实现
sealed class DoorState implements State<DoorState, DoorEvent> {}

class Closed extends DoorState {
  @override
  DoorState? onEvent(DoorEvent event) => switch (event) {
    OpenEvent() => Open(),
    LockEvent() => Locked(),
    _ => null,
  };
}

class Open extends DoorState {
  @override
  DoorState? onEvent(DoorEvent event) => switch (event) {
    CloseEvent() => Closed(),
    _ => null,
  };
}

class Locked extends DoorState {
  @override
  DoorState? onEvent(DoorEvent event) => switch (event) {
    UnlockEvent() => Closed(),
    _ => null,
  };
}

// 事件定义
sealed class DoorEvent implements Event<DoorEvent, DoorState> {}

class OpenEvent extends DoorEvent {}
class CloseEvent extends DoorEvent {}
class LockEvent extends DoorEvent {}
class UnlockEvent extends DoorEvent {}

// 状态机
class StateMachine<S extends State<S, E>, E extends Event<E, S>> {
  S _currentState;
  final _listeners = <void Function(S, S?, E)>[];
  
  StateMachine(this._currentState);
  
  S get currentState => _currentState;
  
  void addListener(void Function(S newState, S? oldState, E event) listener) {
    _listeners.add(listener);
  }
  
  bool dispatch(E event) {
    var newState = _currentState.onEvent(event);
    if (newState != null) {
      var oldState = _currentState;
      _currentState = newState;
      for (var listener in _listeners) {
        listener(newState, oldState, event);
      }
      return true;
    }
    return false;  // 事件被拒绝
  }
}

void main() {
  var door = StateMachine<DoorState, DoorEvent>(Closed());
  
  door.addListener((newState, oldState, event) {
    print('State changed: ${oldState?.runtimeType} -> ${newState.runtimeType}');
  });
  
  door.dispatch(OpenEvent());   // Closed -> Open
  door.dispatch(CloseEvent());  // Open -> Closed
  door.dispatch(LockEvent());   // Closed -> Locked
  door.dispatch(OpenEvent());   // 被拒绝（Locked 不能打开）
  door.dispatch(UnlockEvent()); // Locked -> Closed
}
```

## 第7章 类型系统高级特性

### 7.1 扩展类型（Extension Types）

Dart 3.0 引入了扩展类型，为现有类型提供不同的接口，零运行时开销。

```dart
// 定义扩展类型
extension type Id(int value) {
  bool get isValid => value > 0;
  
  @override
  String toString() => 'Id($value)';
}

// 带命名构造函数的扩展类型
extension type NonNegativeInt._(int value) {
  NonNegativeInt(int value) : assert(value >= 0), value = value;
  
  NonNegativeInt.zero() : value = 0;
  NonNegativeInt.one() : value = 1;
  
  NonNegativeInt operator +(NonNegativeInt other) => 
    NonNegativeInt(value + other.value);
}

// 实现接口的扩展类型
extension type Sequence<T>(List<T> list) implements Iterable<T> {
  T get first => list.first;
  T get last => list.last;
  int get length => list.length;
  
  Sequence<T> subsequence(int start, int end) => 
    Sequence(list.sublist(start, end));
}

// 使用扩展类型进行类型安全的包装
extension type Email(String value) {
  bool get isValid {
    return RegExp(r'^[\w\.-]+@[\w\.-]+\.\w+$').hasMatch(value);
  }
}

extension type PhoneNumber(String value) {
  bool get isValid {
    return RegExp(r'^\+?[\d\s-]+$').hasMatch(value);
  }
}

void main() {
  var id = Id(42);
  print(id.isValid);  // 输出: true
  print(id);          // 输出: Id(42)
  
  // id.isEven;  // 错误: Id 没有 isEven 方法
  
  var nn = NonNegativeInt(10);
  print(nn + NonNegativeInt(5));  // 输出: NonNegativeInt(15)
  
  var email = Email('test@example.com');
  print(email.isValid);  // 输出: true
  
  // 防止类型混淆
  processEmail(email);   // 正确
  // processEmail(PhoneNumber('123'));  // 错误: 类型不匹配
}

void processEmail(Email email) {
  print('Processing: ${email.value}');
}
```

### 7.2 记录类型（Records）

Dart 3.0 引入了记录类型，用于创建匿名的、不可变的复合类型。

```dart
void main() {
  // 位置字段记录
  var point = (3, 4);
  print(point.$1);  // 输出: 3
  print(point.$2);  // 输出: 4
  
  // 命名字段记录
  var person = (name: 'Alice', age: 25);
  print(person.name);  // 输出: Alice
  print(person.age);   // 输出: 25
  
  // 混合记录
  var mixed = ('Hello', name: 'World', 42);
  print(mixed.$1);     // 输出: Hello
  print(mixed.name);   // 输出: World
  print(mixed.$2);     // 输出: 42
  
  // 记录类型注解
  (String, int) namedPoint = ('A', 10);
  ({String x, int y}) coordinate = (x: 5, y: 10);
  
  // 记录解构
  var (x, y) = point;
  print('x=$x, y=$y');  // 输出: x=3, y=4
  
  var (name: n, age: a) = person;
  print('name=$n, age=$a');  // 输出: name=Alice, age=25
  
  // 在函数返回类型中使用
  var (min, max) = findMinMax([3, 1, 4, 1, 5, 9, 2, 6]);
  print('Min: $min, Max: $max');  // 输出: Min: 1, Max: 9
  
  // 记录相等性
  var r1 = (1, 2);
  var r2 = (1, 2);
  print(r1 == r2);  // 输出: true
}

(int, int) findMinMax(List<int> numbers) {
  return (numbers.reduce((a, b) => a < b ? a : b),
          numbers.reduce((a, b) => a > b ? a : b));
}
```

### 7.3 类修饰符与类型系统

Dart 3.0 引入了类修饰符，影响类型的使用和继承方式。

```dart
// base: 强制继承实现
base class Vehicle {
  void move() => print('Moving');
}

// interface: 仅可实现
interface class Logger {
  void log(String message) => print('LOG: $message');
}

// final: 禁止子类型化
final class SecureData {
  final String _data;
  SecureData(this._data);
}

// sealed: 穷尽性检查
sealed class Result<T> {}

class Success<T> extends Result<T> {
  final T data;
  Success(this.data);
}

class Failure<T> extends Result<T> {
  final String error;
  Failure(this.error);
}

// 使用 sealed 类进行穷尽性检查
String handleResult<T>(Result<T> result) {
  return switch (result) {
    Success(data: var d) => 'Success: $d',
    Failure(error: var e) => 'Error: $e',
  };
}

// 混合修饰符
interface class DataSource {}
base class DatabaseSource implements DataSource {}

void main() {
  // base 类必须继承
  class Car extends Vehicle {
    @override
    void move() => print('Driving');
  }
  
  // interface 类必须实现
  class FileLogger implements Logger {
    @override
    void log(String message) => print('Writing to file: $message');
  }
  
  // final 类不能继承或实现
  var secure = SecureData('secret');
  // class MySecureData extends SecureData {}  // 错误
  
  var result = Success<int>(42);
  print(handleResult(result));  // 输出: Success: 42
}
```

## 第8章 实战应用示例

### 8.1 类型安全的 Repository 模式

```dart
// 实体接口
abstract class Entity {
  String get id;
}

// 用户实体
class User implements Entity {
  @override
  final String id;
  final String name;
  final String email;
  
  User({required this.id, required this.name, required this.email});
  
  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      name: json['name'],
      email: json['email'],
    );
  }
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'email': email,
  };
}

// 泛型仓储接口
abstract class Repository<T extends Entity> {
  Future<T?> findById(String id);
  Future<List<T>> findAll();
  Future<T> save(T entity);
  Future<void> delete(String id);
  Stream<T> watch(String id);
  Stream<List<T>> watchAll();
}

// 内存仓储实现
class InMemoryRepository<T extends Entity> implements Repository<T> {
  final Map<String, T> _storage = {};
  final _controllers = <String, StreamController<T>>{};
  final _allController = StreamController<List<T>>.broadcast();
  
  @override
  Future<T?> findById(String id) async => _storage[id];
  
  @override
  Future<List<T>> findAll() async => _storage.values.toList();
  
  @override
  Future<T> save(T entity) async {
    _storage[entity.id] = entity;
    _notify(entity);
    return entity;
  }
  
  @override
  Future<void> delete(String id) async {
    _storage.remove(id);
    _notifyAll();
  }
  
  @override
  Stream<T> watch(String id) {
    return _controllers.putIfAbsent(
      id,
      () => StreamController<T>.broadcast(),
    ).stream;
  }
  
  @override
  Stream<List<T>> watchAll() => _allController.stream;
  
  void _notify(T entity) {
    _controllers[entity.id]?.add(entity);
    _notifyAll();
  }
  
  void _notifyAll() {
    _allController.add(_storage.values.toList());
  }
  
  void dispose() {
    _controllers.values.forEach((c) => c.close());
    _allController.close();
  }
}

// 使用
void main() async {
  var userRepo = InMemoryRepository<User>();
  
  // 监听所有用户变化
  userRepo.watchAll().listen((users) {
    print('Users updated: ${users.length}');
  });
  
  // 保存用户
  var user = await userRepo.save(
    User(id: '1', name: 'Alice', email: 'alice@example.com'),
  );
  
  // 查询用户
  var found = await userRepo.findById('1');
  print('Found: ${found?.name}');  // 输出: Found: Alice
}
```

### 8.2 类型安全的 API 客户端

```dart
import 'dart:convert';

// API 响应封装
sealed class ApiResponse<T> {}

class ApiSuccess<T> extends ApiResponse<T> {
  final T data;
  final int statusCode;
  ApiSuccess(this.data, this.statusCode);
}

class ApiError<T> extends ApiResponse<T> {
  final String message;
  final int statusCode;
  ApiError(this.message, this.statusCode);
}

// 类型转换器
abstract class JsonConverter<T> {
  T fromJson(Map<String, dynamic> json);
  Map<String, dynamic> toJson(T object);
}

// API 客户端
class ApiClient {
  final String baseUrl;
  
  ApiClient({required this.baseUrl});
  
  Future<ApiResponse<T>> get<T>(
    String path, {
    required JsonConverter<T> converter,
    Map<String, String>? headers,
  }) async {
    try {
      // 模拟 HTTP 请求
      await Future.delayed(Duration(milliseconds: 100));
      
      // 模拟成功响应
      var mockJson = {'id': '1', 'name': 'Test'};
      return ApiSuccess(converter.fromJson(mockJson), 200);
    } catch (e) {
      return ApiError(e.toString(), 500);
    }
  }
  
  Future<ApiResponse<List<T>>> getList<T>(
    String path, {
    required JsonConverter<T> converter,
  }) async {
    try {
      await Future.delayed(Duration(milliseconds: 100));
      
      var mockList = [
        {'id': '1', 'name': 'Item 1'},
        {'id': '2', 'name': 'Item 2'},
      ];
      return ApiSuccess(
        mockList.map((j) => converter.fromJson(j)).toList(),
        200,
      );
    } catch (e) {
      return ApiError(e.toString(), 500);
    }
  }
}

// 具体转换器实现
class UserConverter implements JsonConverter<User> {
  @override
  User fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      name: json['name'],
      email: json['email'] ?? '',
    );
  }
  
  @override
  Map<String, dynamic> toJson(User user) => user.toJson();
}

// 使用
void main() async {
  var client = ApiClient(baseUrl: 'https://api.example.com');
  
  var response = await client.get<User>(
    '/users/1',
    converter: UserConverter(),
  );
  
  switch (response) {
    case ApiSuccess(data: var user, statusCode: var code):
      print('Success ($code): ${user.name}');
    case ApiError(message: var msg, statusCode: var code):
      print('Error ($code): $msg');
  }
}
```

### 8.3 Flutter 中的泛型 Widget

```dart
import 'package:flutter/material.dart';

// 泛型列表组件
class GenericListView<T> extends StatelessWidget {
  final List<T> items;
  final Widget Function(BuildContext, T) itemBuilder;
  final void Function(T)? onItemTap;
  final EdgeInsets padding;
  
  const GenericListView({
    Key? key,
    required this.items,
    required this.itemBuilder,
    this.onItemTap,
    this.padding = const EdgeInsets.all(8),
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: padding,
      itemCount: items.length,
      itemBuilder: (context, index) {
        final item = items[index];
        return GestureDetector(
          onTap: onItemTap != null ? () => onItemTap!(item) : null,
          child: itemBuilder(context, item),
        );
      },
    );
  }
}

// 泛型表单字段
class FormFieldConfig<T> {
  final String label;
  final T? initialValue;
  final String? Function(T?)? validator;
  final void Function(T?)? onChanged;
  final Widget Function(BuildContext, T?, void Function(T?)) builder;
  
  FormFieldConfig({
    required this.label,
    this.initialValue,
    this.validator,
    this.onChanged,
    required this.builder,
  });
}

class GenericForm<T> extends StatefulWidget {
  final Map<String, FormFieldConfig<dynamic>> fields;
  final void Function(Map<String, dynamic>) onSubmit;
  
  const GenericForm({
    Key? key,
    required this.fields,
    required this.onSubmit,
  }) : super(key: key);
  
  @override
  _GenericFormState createState() => _GenericFormState();
}

class _GenericFormState extends State<GenericForm> {
  final _formKey = GlobalKey<FormState>();
  final _values = <String, dynamic>{};
  
  @override
  void initState() {
    super.initState();
    widget.fields.forEach((key, config) {
      _values[key] = config.initialValue;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        children: [
          ...widget.fields.entries.map((entry) {
            final key = entry.key;
            final config = entry.value;
            return config.builder(
              context,
              _values[key],
              (value) => setState(() => _values[key] = value),
            );
          }).toList(),
          ElevatedButton(
            onPressed: () {
              if (_formKey.currentState!.validate()) {
                widget.onSubmit(_values);
              }
            },
            child: Text('Submit'),
          ),
        ],
      ),
    );
  }
}

// 使用示例
class UserListPage extends StatelessWidget {
  final users = [
    User(id: '1', name: 'Alice', email: 'alice@example.com'),
    User(id: '2', name: 'Bob', email: 'bob@example.com'),
  ];
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Users')),
      body: GenericListView<User>(
        items: users,
        onItemTap: (user) => print('Tapped: ${user.name}'),
        itemBuilder: (context, user) => ListTile(
          title: Text(user.name),
          subtitle: Text(user.email),
        ),
      ),
    );
  }
}
```

## 附录：泛型与类型系统速查表

| 特性 | 语法/关键字 | 说明 |
|------|----------|------|
| 泛型类 | `class Name<T> {}` | 带类型参数的类 |
| 泛型方法 | `T method<T>(T param)` | 带类型参数的方法 |
| 类型约束 | `T extends Base` | 限制类型参数范围 |
| 协变 | `covariant` | 子类收紧参数类型 |
| 逆变 | 参数位置使用 | 父类型替代子类型 |
| 不变 | 默认 | 类型参数无型变 |
| 类型推断 | `var x = value` | 自动推断类型 |
| sealed 类 | `sealed class` | 穷尽性检查 |
| 模式匹配 | `switch (x) { case pattern => ... }` | 解构和匹配 |
| 记录类型 | `(int, String)` 或 `({int x, int y})` | 匿名复合类型 |
| 扩展类型 | `extension type Name(T value)` | 零开销类型包装 |
| base 类 | `base class` | 强制继承 |
| interface 类 | `interface class` | 仅可实现 |
| final 类 | `final class` | 禁止子类型化 |
| 类型别名 | `typedef Name = Type` | 类型重命名 |

---

本文档详细介绍了 Dart 语言的泛型与类型系统，从基础的泛型类和方法，到高级的类型约束、型变、模式匹配和穷尽性检查。掌握这些内容将帮助你编写出类型安全、可维护的 Dart 代码，特别是在大型项目和 Flutter 开发中能够更好地组织代码结构和处理复杂类型关系。
