# Dart 语言异步编程详解

异步编程是现代软件开发中不可或缺的一部分，特别是在处理 I/O 操作、网络请求、文件读写等耗时任务时。Dart 提供了强大的异步编程支持，主要通过 `Future` 和 `Stream` 两个核心类来实现。`Future` 代表一个异步操作的单一结果，而 `Stream` 代表一个异步事件序列。本章将系统且全面地介绍 Dart 语言的异步编程机制，从基础的 `Future` 和 `async/await` 到高级的 `Stream` 处理、转换和操作，配合大量实例代码，帮助读者深入理解并熟练运用 Dart 的异步编程能力。

## 第1章 Future 详解

`Future` 是 Dart 中表示异步操作结果的对象。它代表一个可能还没有完成的计算，在未来某个时刻会返回一个值或错误。

### 1.1 Future 的基本概念

#### 1.1.1 创建 Future

Dart 提供了多种方式创建 `Future` 对象：

```dart
import 'dart:async';

void main() {
  // 1. 使用 Future 构造函数
  Future<String> future1 = Future(() {
    return 'Hello from Future';
  });

  // 2. 使用 Future.value 创建已完成的 Future
  Future<String> future2 = Future.value('Immediate value');

  // 3. 使用 Future.error 创建已失败的 Future
  Future<String> future3 = Future.error(Exception('Something went wrong'));

  // 4. 使用 Future.delayed 创建延迟执行的 Future
  Future<String> future4 = Future.delayed(
    Duration(seconds: 2),
    () => 'Delayed result',
  );

  // 5. 使用 Future.microtask 创建微任务
  Future<String> future5 = Future.microtask(() => 'Microtask result');

  // 6. 使用 Future.sync 同步执行
  Future<String> future6 = Future.sync(() => 'Sync result');
}
```

#### 1.1.2 Future 的状态

一个 `Future` 可以处于以下三种状态之一：

1. **未完成（Uncompleted）**：异步操作正在进行中
2. **已完成并返回数据（Completed with data）**：操作成功完成，返回了值
3. **已完成并返回错误（Completed with error）**：操作失败，返回了错误

```dart
void main() {
  // 未完成的 Future
  var future = fetchData();
  print(future);  // 输出: Instance of '_Future<String>'

  // 等待 Future 完成
  future.then((value) {
    print('Completed with: $value');
  });
}

Future<String> fetchData() async {
  await Future.delayed(Duration(seconds: 1));
  return 'Data loaded';
}
```

### 1.2 Future 的常用属性

#### 1.2.1 then

`then` 方法用于注册一个回调函数，当 `Future` 成功完成时会被调用。

```dart
void main() {
  Future<String> future = Future.value('Hello');

  future.then((value) {
    print('Success: $value');  // 输出: Success: Hello
  });

  // 链式调用
  Future.value(5)
    .then((value) => value * 2)
    .then((value) => value + 1)
    .then((value) => print('Result: $value'));  // 输出: Result: 11
}
```

#### 1.2.2 catchError

`catchError` 方法用于处理 `Future` 执行过程中抛出的错误。

```dart
void main() {
  Future<int> future = Future.error(Exception('Calculation failed'));

  future
    .then((value) => print('Value: $value'))
    .catchError((error) {
      print('Error caught: $error');  // 输出: Error caught: Exception: Calculation failed
    });

  // 带类型检查的错误处理
  Future<int> riskyOperation = Future(() => throw FormatException('Invalid format'));

  riskyOperation.catchError((error) {
    if (error is FormatException) {
      print('Format error: ${error.message}');
    }
    return -1;  // 返回默认值
  }).then((value) => print('Result: $value'));
}
```

#### 1.2.3 whenComplete

`whenComplete` 方法无论 `Future` 成功还是失败都会执行，类似于 `try-finally` 中的 `finally` 块。

```dart
void main() {
  Future<String> future = fetchData();

  future
    .then((value) => print('Success: $value'))
    .catchError((error) => print('Error: $error'))
    .whenComplete(() => print('Operation completed'));  // 总会执行
}

Future<String> fetchData() async {
  await Future.delayed(Duration(seconds: 1));
  // 随机成功或失败
  if (DateTime.now().millisecond % 2 == 0) {
    return 'Data';
  } else {
    throw Exception('Failed');
  }
}
```

#### 1.2.4 timeout

`timeout` 方法为 `Future` 设置超时时间，如果超时则抛出 `TimeoutException`。

```dart
void main() async {
  // 设置超时
  try {
    var result = await fetchSlowData()
      .timeout(Duration(seconds: 2));
    print('Result: $result');
  } on TimeoutException {
    print('Operation timed out');
  }

  // 超时返回默认值
  var result = await fetchSlowData()
    .timeout(
      Duration(seconds: 1),
      onTimeout: () => Future.value('Default value'),
    );
  print('Result: $result');  // 输出: Default value
}

Future<String> fetchSlowData() async {
  await Future.delayed(Duration(seconds: 5));
  return 'Slow data';
}
```

### 1.3 Future 的静态方法

#### 1.3.1 Future.wait

`Future.wait` 等待多个 `Future` 全部完成，返回一个包含所有结果的列表。

```dart
void main() async {
  // 并行执行多个异步操作
  var results = await Future.wait([
    fetchUserData(),
    fetchUserOrders(),
    fetchUserSettings(),
  ]);

  print('User: ${results[0]}');
  print('Orders: ${results[1]}');
  print('Settings: ${results[2]}');

  // 带类型参数
  var typedResults = await Future.wait<String>([
    Future.value('A'),
    Future.value('B'),
    Future.value('C'),
  ]);
  print(typedResults);  // 输出: [A, B, C]
}

Future<String> fetchUserData() async {
  await Future.delayed(Duration(seconds: 1));
  return 'User: Alice';
}

Future<String> fetchUserOrders() async {
  await Future.delayed(Duration(seconds: 2));
  return 'Orders: 5';
}

Future<String> fetchUserSettings() async {
  await Future.delayed(Duration(seconds: 1));
  return 'Settings: dark mode';
}
```

#### 1.3.2 Future.any

`Future.any` 返回最先完成的 `Future` 的结果。

```dart
void main() async {
  // 多个数据源，取最快的结果
  var fastestResult = await Future.any([
    fetchFromCache(),
    fetchFromNetwork(),
    fetchFromDatabase(),
  ]);

  print('Fastest result: $fastestResult');
}

Future<String> fetchFromCache() async {
  await Future.delayed(Duration(milliseconds: 100));
  return 'Cache data';
}

Future<String> fetchFromNetwork() async {
  await Future.delayed(Duration(seconds: 2));
  return 'Network data';
}

Future<String> fetchFromDatabase() async {
  await Future.delayed(Duration(milliseconds: 500));
  return 'Database data';
}
```

#### 1.3.3 Future.forEach

`Future.forEach` 按顺序对集合中的每个元素执行异步操作。

```dart
void main() async {
  var items = ['A', 'B', 'C', 'D'];

  await Future.forEach<String>(items, (item) async {
    await processItem(item);
  });

  print('All items processed');
}

Future<void> processItem(String item) async {
  await Future.delayed(Duration(milliseconds: 500));
  print('Processed: $item');
}
```

#### 1.3.4 Future.doWhile

`Future.doWhile` 重复执行异步操作，直到条件不满足。

```dart
void main() async {
  var count = 0;

  await Future.doWhile(() async {
    await Future.delayed(Duration(milliseconds: 100));
    count++;
    print('Iteration: $count');
    return count < 5;  // 继续循环的条件
  });

  print('Loop finished');
}
```

### 1.4 async 和 await

`async` 和 `await` 是 Dart 提供的语法糖，让异步代码看起来像同步代码，提高可读性。

#### 1.4.1 基本用法

```dart
// 使用 async 标记异步函数
Future<String> fetchUser() async {
  // 使用 await 等待异步操作完成
  await Future.delayed(Duration(seconds: 1));
  return 'Alice';
}

// 异步函数返回 Future
Future<int> calculate() async {
  var a = await fetchNumberA();  // 等待 fetchNumberA 完成
  var b = await fetchNumberB();  // 等待 fetchNumberB 完成
  return a + b;
}

Future<int> fetchNumberA() async {
  await Future.delayed(Duration(milliseconds: 500));
  return 10;
}

Future<int> fetchNumberB() async {
  await Future.delayed(Duration(milliseconds: 500));
  return 20;
}

void main() async {
  print('Start');

  var user = await fetchUser();
  print('User: $user');

  var result = await calculate();
  print('Result: $result');  // 输出: 30

  print('End');
}
```

#### 1.4.2 错误处理

使用 `try-catch` 块处理异步操作中的错误。

```dart
Future<String> riskyOperation() async {
  await Future.delayed(Duration(seconds: 1));
  throw Exception('Something went wrong');
}

void main() async {
  try {
    var result = await riskyOperation();
    print('Success: $result');
  } catch (e) {
    print('Error: $e');  // 输出: Error: Exception: Something went wrong
  } finally {
    print('Cleanup code here');  // 总会执行
  }

  // 多个 catch 块
  try {
    await anotherRiskyOperation();
  } on FormatException catch (e) {
    print('Format error: ${e.message}');
  } on TimeoutException {
    print('Operation timed out');
  } catch (e, stackTrace) {
    print('Unknown error: $e');
    print('Stack trace: $stackTrace');
  }
}

Future<void> anotherRiskyOperation() async {
  throw FormatException('Invalid input');
}
```

#### 1.4.3 并行执行

使用 `Future.wait` 并行执行多个独立的异步操作。

```dart
void main() async {
  // 串行执行（总耗时 = 1s + 2s + 3s = 6s）
  var start1 = DateTime.now();
  var a = await fetchA();  // 1s
  var b = await fetchB();  // 2s
  var c = await fetchC();  // 3s
  print('Serial: ${DateTime.now().difference(start1)}');  // ~6s

  // 并行执行（总耗时 = max(1s, 2s, 3s) = 3s）
  var start2 = DateTime.now();
  var results = await Future.wait([fetchA(), fetchB(), fetchC()]);
  print('Parallel: ${DateTime.now().difference(start2)}');  // ~3s
}

Future<String> fetchA() async {
  await Future.delayed(Duration(seconds: 1));
  return 'A';
}

Future<String> fetchB() async {
  await Future.delayed(Duration(seconds: 2));
  return 'B';
}

Future<String> fetchC() async {
  await Future.delayed(Duration(seconds: 3));
  return 'C';
}
```

**Dart Tips 语法小贴士**

避免 async/await 的嵌套地狱

虽然 `async/await` 大大改善了异步代码的可读性，但不当使用仍会导致问题。以下是一些最佳实践：

```dart
// 不推荐: 不必要的 await
Future<String> badExample() async {
  return await fetchData();  // await 是多余的
}

// 推荐: 直接返回 Future
Future<String> goodExample() {
  return fetchData();  // 更简洁，没有额外的 await 开销
}

// 不推荐: 串行执行可以并行的操作
Future<void> badParallel() async {
  var users = await fetchUsers();      // 等待
  var orders = await fetchOrders();    // 等待
  var products = await fetchProducts(); // 等待
}

// 推荐: 并行执行
Future<void> goodParallel() async {
  var results = await Future.wait([
    fetchUsers(),
    fetchOrders(),
    fetchProducts(),
  ]);
}
```

## 第2章 Stream 详解

`Stream` 是 Dart 中表示异步事件序列的对象。与 `Future` 代表单一异步结果不同，`Stream` 可以产生多个值，适用于处理持续的数据流，如用户输入、文件读取、WebSocket 消息等。

### 2.1 Stream 的基本概念

#### 2.1.1 Stream 的类型

Dart 中的 `Stream` 分为两种类型：

1. **单订阅流（Single-subscription Stream）**：只能有一个监听器，数据按顺序发送给该监听器
2. **广播流（Broadcast Stream）**：可以有多个监听器，数据同时发送给所有监听器

```dart
void main() {
  // 单订阅流（默认）
  Stream<int> singleStream = Stream.fromIterable([1, 2, 3]);

  singleStream.listen((data) => print('Listener 1: $data'));
  // singleStream.listen((data) => print('Listener 2: $data'));  // 错误: 单订阅流不能重复监听

  // 广播流
  Stream<int> broadcastStream = Stream.fromIterable([1, 2, 3]).asBroadcastStream();

  broadcastStream.listen((data) => print('A: $data'));
  broadcastStream.listen((data) => print('B: $data'));
}
```

#### 2.1.2 创建 Stream

Dart 提供了多种方式创建 `Stream`：

```dart
void main() {
  // 1. 使用 Stream 构造函数
  Stream<int> stream1 = Stream.periodic(
    Duration(seconds: 1),
    (count) => count,
  ).take(5);  // 取前5个

  // 2. 从 Iterable 创建
  Stream<int> stream2 = Stream.fromIterable([1, 2, 3, 4, 5]);

  // 3. 从 Future 创建
  Stream<String> stream3 = Stream.fromFuture(Future.value('Hello'));

  // 4. 从多个 Future 创建
  Stream<String> stream4 = Stream.fromFutures([
    Future.value('A'),
    Future.value('B'),
    Future.value('C'),
  ]);

  // 5. 使用 async* 生成器
  Stream<int> stream5 = countStream(5);

  // 6. 使用 StreamController
  StreamController<int> controller = StreamController<int>();
  Stream<int> stream6 = controller.stream;
  controller.add(1);
  controller.add(2);
  controller.close();
}

// async* 生成器创建 Stream
Stream<int> countStream(int max) async* {
  for (int i = 0; i < max; i++) {
    await Future.delayed(Duration(milliseconds: 100));
    yield i;  // 产生一个值
  }
}
```

### 2.2 Stream 的监听

#### 2.2.1 listen 方法

`listen` 是 `Stream` 最核心的方法，用于订阅流并接收事件。

```dart
void main() {
  Stream<int> stream = Stream.periodic(
    Duration(seconds: 1),
    (count) => count,
  ).take(5);

  // 基本监听
  stream.listen(
    (data) => print('Data: $data'),           // onData: 收到数据
    onError: (error) => print('Error: $error'), // onError: 发生错误
    onDone: () => print('Stream closed'),      // onDone: 流关闭
    cancelOnError: false,  // 错误时不自动取消订阅
  );
}
```

#### 2.2.2 StreamSubscription

`listen` 方法返回一个 `StreamSubscription` 对象，用于控制订阅。

```dart
void main() async {
  Stream<int> stream = Stream.periodic(
    Duration(seconds: 1),
    (count) => count,
  );

  StreamSubscription<int> subscription = stream.listen(
    (data) => print('Received: $data'),
  );

  // 暂停订阅
  await Future.delayed(Duration(seconds: 3));
  print('Pausing...');
  subscription.pause();

  // 恢复订阅
  await Future.delayed(Duration(seconds: 2));
  print('Resuming...');
  subscription.resume();

  // 取消订阅
  await Future.delayed(Duration(seconds: 3));
  print('Canceling...');
  subscription.cancel();
}
```

### 2.3 Stream 的常用属性

#### 2.3.1 first、last、length

```dart
void main() async {
  Stream<int> stream = Stream.fromIterable([1, 2, 3, 4, 5]);

  // first: 获取第一个元素
  print(await stream.first);  // 输出: 1

  // last: 获取最后一个元素
  print(await Stream.fromIterable([1, 2, 3]).last);  // 输出: 3

  // length: 获取元素数量
  print(await Stream.fromIterable([1, 2, 3, 4]).length);  // 输出: 4

  // isEmpty: 检查是否为空
  print(await Stream.empty().isEmpty);  // 输出: true

  // single: 获取唯一元素（流必须只有一个元素）
  print(await Stream.fromIterable([42]).single);  // 输出: 42
}
```

#### 2.3.2 any 和 every

```dart
void main() async {
  Stream<int> stream = Stream.fromIterable([2, 4, 6, 8, 10]);

  // any: 是否有至少一个元素满足条件
  print(await stream.any((n) => n > 5));   // 输出: true
  print(await Stream.fromIterable([1, 2, 3]).any((n) => n > 10));  // 输出: false

  // every: 是否所有元素都满足条件
  print(await Stream.fromIterable([2, 4, 6]).every((n) => n.isEven));  // 输出: true
  print(await Stream.fromIterable([1, 2, 3]).every((n) => n.isEven));  // 输出: false

  // contains: 是否包含指定元素
  print(await Stream.fromIterable([1, 2, 3]).contains(2));  // 输出: true
}
```

#### 2.3.3 elementAt

```dart
void main() async {
  Stream<String> stream = Stream.fromIterable(['A', 'B', 'C', 'D', 'E']);

  // elementAt: 获取指定索引的元素
  print(await stream.elementAt(2));  // 输出: C

  // firstWhere: 第一个满足条件的元素
  print(await Stream.fromIterable([1, 2, 3, 4, 5])
    .firstWhere((n) => n > 3));  // 输出: 4

  // lastWhere: 最后一个满足条件的元素
  print(await Stream.fromIterable([1, 2, 3, 4, 5])
    .lastWhere((n) => n < 4));  // 输出: 3

  // singleWhere: 唯一满足条件的元素
  print(await Stream.fromIterable([1, 2, 3, 4, 5])
    .singleWhere((n) => n == 3));  // 输出: 3
}
```

### 2.4 Stream 的转换方法

#### 2.4.1 map

`map` 方法将流中的每个元素转换为新的值。

```dart
void main() async {
  Stream<int> numbers = Stream.fromIterable([1, 2, 3, 4, 5]);

  // 基本映射
  Stream<int> doubled = numbers.map((n) => n * 2);
  await for (var n in doubled) {
    print(n);  // 输出: 2, 4, 6, 8, 10
  }

  // 类型转换
  Stream<String> strings = Stream.fromIterable([1, 2, 3])
    .map((n) => 'Number $n');
  await for (var s in strings) {
    print(s);  // 输出: Number 1, Number 2, Number 3
  }

  // 异步映射 (asyncMap)
  Stream<String> asyncMapped = Stream.fromIterable([1, 2, 3])
    .asyncMap((n) async {
      await Future.delayed(Duration(milliseconds: 100));
      return 'Processed $n';
    });
  await for (var s in asyncMapped) {
    print(s);
  }
}
```

#### 2.4.2 where

`where` 方法过滤流中的元素，只保留满足条件的元素。

```dart
void main() async {
  Stream<int> numbers = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

  // 过滤偶数
  Stream<int> evens = numbers.where((n) => n.isEven);
  await for (var n in evens) {
    print(n);  // 输出: 2, 4, 6, 8, 10
  }

  // 复合条件
  Stream<int> filtered = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    .where((n) => n > 3 && n.isOdd);
  await for (var n in filtered) {
    print(n);  // 输出: 5, 7, 9
  }
}
```

#### 2.4.3 take 和 skip

```dart
void main() async {
  Stream<int> numbers = Stream.fromIterable([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

  // take: 取前 n 个元素
  Stream<int> first3 = numbers.take(3);
  await for (var n in first3) {
    print(n);  // 输出: 1, 2, 3
  }

  // skip: 跳过前 n 个元素
  Stream<int> skipped = Stream.fromIterable([1, 2, 3, 4, 5]).skip(2);
  await for (var n in skipped) {
    print(n);  // 输出: 3, 4, 5
  }

  // takeWhile: 取元素直到条件不满足
  Stream<int> takenWhile = Stream.fromIterable([1, 2, 3, 4, 5, 1, 2])
    .takeWhile((n) => n < 4);
  await for (var n in takenWhile) {
    print(n);  // 输出: 1, 2, 3
  }

  // skipWhile: 跳过元素直到条件不满足
  Stream<int> skippedWhile = Stream.fromIterable([1, 2, 3, 4, 5, 1, 2])
    .skipWhile((n) => n < 4);
  await for (var n in skippedWhile) {
    print(n);  // 输出: 4, 5, 1, 2
  }
}
```

#### 2.4.4 expand

`expand` 将每个元素展开为零个或多个元素。

```dart
void main() async {
  // 扁平化嵌套列表
  Stream<List<int>> nested = Stream.fromIterable([
    [1, 2],
    [3, 4],
    [5, 6],
  ]);

  Stream<int> flattened = nested.expand((list) => list);
  await for (var n in flattened) {
    print(n);  // 输出: 1, 2, 3, 4, 5, 6
  }

  // 生成多个元素
  Stream<int> repeated = Stream.fromIterable([1, 2, 3])
    .expand((n) => [n, n, n]);
  await for (var n in repeated) {
    print(n);  // 输出: 1, 1, 1, 2, 2, 2, 3, 3, 3
  }
}
```

#### 2.4.5 distinct

`distinct` 方法过滤掉连续重复的元素。

```dart
void main() async {
  Stream<int> withDuplicates = Stream.fromIterable([1, 1, 2, 2, 2, 3, 3, 1]);

  // 基本去重（连续重复）
  Stream<int> distinct = withDuplicates.distinct();
  await for (var n in distinct) {
    print(n);  // 输出: 1, 2, 3, 1
  }

  // 自定义相等性判断
  Stream<String> words = Stream.fromIterable(['Apple', 'apple', 'Banana', 'banana']);
  Stream<String> caseInsensitiveDistinct = words.distinct(
    (prev, next) => prev.toLowerCase() == next.toLowerCase(),
  );
  await for (var w in caseInsensitiveDistinct) {
    print(w);  // 输出: Apple, Banana
  }
}
```

### 2.5 Stream 的聚合方法

#### 2.5.1 reduce

`reduce` 将流中的元素累积为一个值。

```dart
void main() async {
  Stream<int> numbers = Stream.fromIterable([1, 2, 3, 4, 5]);

  // 求和
  int sum = await numbers.reduce((a, b) => a + b);
  print(sum);  // 输出: 15

  // 求最大值
  int max = await Stream.fromIterable([3, 1, 4, 1, 5, 9, 2, 6])
    .reduce((a, b) => a > b ? a : b);
  print(max);  // 输出: 9

  // 字符串连接
  String concatenated = await Stream.fromIterable(['H', 'e', 'l', 'l', 'o'])
    .reduce((a, b) => a + b);
  print(concatenated);  // 输出: Hello
}
```

#### 2.5.2 fold

`fold` 与 `reduce` 类似，但可以指定初始值。

```dart
void main() async {
  Stream<int> numbers = Stream.fromIterable([1, 2, 3, 4, 5]);

  // 带初始值的求和
  int sum = await numbers.fold<int>(10, (prev, curr) => prev + curr);
  print(sum);  // 输出: 25 (10 + 1 + 2 + 3 + 4 + 5)

  // 构建 Map
  Stream<String> entries = Stream.fromIterable(['a', 'b', 'c']);
  Map<String, int> map = await entries.fold<Map<String, int>>(
    {},
    (prev, curr) => prev..[curr] = curr.codeUnitAt(0),
  );
  print(map);  // 输出: {a: 97, b: 98, c: 99}

  // 字符串连接带分隔符
  String sentence = await Stream.fromIterable(['Hello', 'Dart', 'World'])
    .fold<String>('', (prev, curr) => prev.isEmpty ? curr : '$prev $curr');
  print(sentence);  // 输出: Hello Dart World
}
```

#### 2.5.3 join

`join` 将流中的所有元素连接成一个字符串。

```dart
void main() async {
  Stream<String> words = Stream.fromIterable(['Hello', 'World']);

  // 无分隔符
  String noSeparator = await words.join();
  print(noSeparator);  // 输出: HelloWorld

  // 带分隔符
  String withSeparator = await Stream.fromIterable(['A', 'B', 'C']).join(', ');
  print(withSeparator);  // 输出: A, B, C
}
```

### 2.6 Stream 的合并方法

#### 2.6.1 merge

使用 `StreamGroup.merge` 合并多个流（需要 `async` 包）。

```dart
import 'package:async/async.dart';

void main() async {
  Stream<int> stream1 = Stream.periodic(Duration(seconds: 1), (i) => i).take(3);
  Stream<int> stream2 = Stream.periodic(Duration(milliseconds: 500), (i) => i + 100).take(6);

  // 合并流（交错输出）
  Stream<int> merged = StreamGroup.merge([stream1, stream2]);

  await for (var value in merged) {
    print(value);
  }
  // 输出顺序: 100, 0, 101, 102, 1, 103, 104, 2, 105
}
```

#### 2.6.2 concat

使用 `StreamGroup.merge` 或自定义实现按顺序连接流。

```dart
void main() async {
  Stream<int> stream1 = Stream.fromIterable([1, 2, 3]);
  Stream<int> stream2 = Stream.fromIterable([4, 5, 6]);
  Stream<int> stream3 = Stream.fromIterable([7, 8, 9]);

  // 顺序连接
  Stream<int> concatenated = concatStreams([stream1, stream2, stream3]);

  await for (var value in concatenated) {
    print(value);  // 输出: 1, 2, 3, 4, 5, 6, 7, 8, 9
  }
}

Stream<T> concatStreams<T>(List<Stream<T>> streams) async* {
  for (var stream in streams) {
    yield* stream;
  }
}
```

#### 2.6.3 zip

将多个流的元素按对组合。

```dart
void main() async {
  Stream<String> names = Stream.fromIterable(['Alice', 'Bob', 'Charlie']);
  Stream<int> ages = Stream.fromIterable([25, 30, 35]);

  // 使用 asyncExpand 实现 zip
  Stream<(String, int)> zipped = zipStreams(names, ages);

  await for (var (name, age) in zipped) {
    print('$name is $age years old');
  }
  // 输出:
  // Alice is 25 years old
  // Bob is 30 years old
  // Charlie is 35 years old
}

Stream<(T1, T2)> zipStreams<T1, T2>(Stream<T1> stream1, Stream<T2> stream2) async* {
  await for (var value1 in stream1) {
    await for (var value2 in stream2) {
      yield (value1, value2);
      break;  // 只取 stream2 的第一个元素
    }
  }
}
```

## 第3章 StreamController

`StreamController` 是创建和管理 `Stream` 的核心类，它提供了对流的完全控制。

### 3.1 创建 StreamController

```dart
void main() {
  // 单订阅 StreamController（默认）
  StreamController<String> controller1 = StreamController<String>();

  // 广播 StreamController
  StreamController<String> controller2 = StreamController<String>.broadcast();

  // 带回调的 StreamController
  StreamController<int> controller3 = StreamController<int>(
    onListen: () => print('Stream listened'),
    onPause: () => print('Stream paused'),
    onResume: () => print('Stream resumed'),
    onCancel: () => print('Stream canceled'),
  );
}
```

### 3.2 StreamController 的属性

#### 3.2.1 stream

`stream` 属性返回控制器管理的 `Stream` 对象。

```dart
void main() {
  StreamController<String> controller = StreamController<String>();

  // 获取 stream
  Stream<String> stream = controller.stream;

  // 监听 stream
  stream.listen(
    (data) => print('Received: $data'),
    onDone: () => print('Stream closed'),
  );

  // 添加数据
  controller.add('Hello');
  controller.add('World');

  // 关闭
  controller.close();
}
```

#### 3.2.2 sink

`sink` 是 `StreamSink` 对象，用于向流中添加数据、错误和关闭事件。

```dart
void main() {
  StreamController<String> controller = StreamController<String>();

  // 使用 sink 添加数据
  controller.sink.add('Message 1');
  controller.sink.add('Message 2');

  // 添加错误
  controller.sink.addError(Exception('Something went wrong'));

  // 关闭 sink
  controller.sink.close();
}
```

#### 3.2.3 hasListener

检查流是否有监听器。

```dart
void main() {
  StreamController<String> controller = StreamController<String>();

  print(controller.hasListener);  // 输出: false

  controller.stream.listen((_) {});

  print(controller.hasListener);  // 输出: true
}
```

#### 3.2.4 isClosed 和 isPaused

```dart
void main() async {
  StreamController<String> controller = StreamController<String>();

  print(controller.isClosed);  // 输出: false

  var subscription = controller.stream.listen((_) {});

  print(controller.isPaused);  // 输出: false

  subscription.pause();
  print(controller.isPaused);  // 输出: true

  await controller.close();
  print(controller.isClosed);  // 输出: true
}
```

### 3.3 广播 StreamController

广播流可以有多个监听器，适合事件总线等场景。

```dart
void main() {
  // 创建广播流控制器
  StreamController<String> controller = StreamController<String>.broadcast();

  // 多个监听器
  var subscription1 = controller.stream.listen(
    (data) => print('Listener 1: $data'),
  );

  var subscription2 = controller.stream.listen(
    (data) => print('Listener 2: $data'),
  );

  // 发送事件，所有监听器都会收到
  controller.add('Hello');
  // 输出:
  // Listener 1: Hello
  // Listener 2: Hello

  // 取消单个订阅
  subscription1.cancel();

  // 只有 listener 2 会收到
  controller.add('World');
  // 输出:
  // Listener 2: World

  controller.close();
}
```

### 3.4 同步与异步 StreamController

```dart
void main() {
  // 异步控制器（默认）：事件在微任务中分发
  StreamController<String> asyncController = StreamController<String>();

  // 同步控制器：事件立即分发
  StreamController<String> syncController = StreamController<String>(sync: true);

  // 注意：同步控制器可能导致意外行为，谨慎使用
  syncController.stream.listen((data) => print('Sync: $data'));

  print('Before add');
  syncController.add('Event');  // 立即执行监听器
  print('After add');
  // 输出顺序:
  // Before add
  // Sync: Event
  // After add
}
```

**Flutter 框架小知识**

StreamController 在 Flutter 中的最佳实践

在 Flutter 中使用 `StreamController` 时，务必在 `dispose` 方法中关闭控制器，防止内存泄漏。

```dart
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  final StreamController<String> _controller = StreamController<String>();

  @override
  void dispose() {
    _controller.close();  // 重要：关闭控制器
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<String>(
      stream: _controller.stream,
      builder: (context, snapshot) {
        // ...
      },
    );
  }
}
```

## 第4章 异步生成器

异步生成器使用 `async*` 和 `yield` 关键字创建 `Stream`。

### 4.1 基本异步生成器

```dart
// 使用 async* 创建 Stream
Stream<int> countStream(int max) async* {
  for (int i = 0; i < max; i++) {
    await Future.delayed(Duration(milliseconds: 100));
    yield i;  // 产生一个值
  }
}

// 带条件的异步生成器
Stream<int> evenNumbers(int max) async* {
  for (int i = 0; i < max; i++) {
    if (i.isEven) {
      await Future.delayed(Duration(milliseconds: 50));
      yield i;
    }
  }
}

void main() async {
  // 使用 await for 消费流
  await for (var count in countStream(5)) {
    print('Count: $count');
  }

  // 转换为列表
  var evens = await evenNumbers(10).toList();
  print(evens);  // 输出: [0, 2, 4, 6, 8]
}
```

### 4.2 yield\* 委托

`yield*` 将另一个流的所有元素委托给当前流。

```dart
// 递归遍历树
class TreeNode<T> {
  final T value;
  final List<TreeNode<T>> children;

  TreeNode(this.value, [this.children = const []]);
}

// 深度优先遍历
Stream<T> traverseDFS<T>(TreeNode<T> node) async* {
  yield node.value;
  for (var child in node.children) {
    yield* traverseDFS(child);  // 递归委托
  }
}

// 广度优先遍历
Stream<T> traverseBFS<T>(TreeNode<T> root) async* {
  var queue = [root];

  while (queue.isNotEmpty) {
    var node = queue.removeAt(0);
    yield node.value;
    queue.addAll(node.children);
  }
}

void main() async {
  var tree = TreeNode('A', [
    TreeNode('B', [
      TreeNode('D'),
      TreeNode('E'),
    ]),
    TreeNode('C', [
      TreeNode('F'),
    ]),
  ]);

  print('DFS:');
  await for (var value in traverseDFS(tree)) {
    print(value);  // A, B, D, E, C, F
  }

  print('BFS:');
  await for (var value in traverseBFS(tree)) {
    print(value);  // A, B, C, D, E, F
  }
}
```

### 4.3 异步生成器的错误处理

```dart
Stream<int> riskyStream() async* {
  yield 1;
  yield 2;
  throw Exception('Error at 3');
  yield 3;  // 不会执行
}

Stream<int> safeStream() async* {
  try {
    yield 1;
    yield 2;
    throw Exception('Error at 3');
  } catch (e) {
    print('Caught in generator: $e');
    yield -1;  // 可以 yield 错误标记
  }
}

void main() async {
  // 处理流中的错误
  try {
    await for (var value in riskyStream()) {
      print('Value: $value');
    }
  } catch (e) {
    print('Caught in consumer: $e');
  }

  // 使用 safeStream
  await for (var value in safeStream()) {
    print('Value: $value');
  }
}
```

## 第5章 FutureBuilder 和 StreamBuilder

`FutureBuilder` 和 `StreamBuilder` 是 Flutter 中用于将异步数据绑定到 UI 的 Widget。

### 5.1 FutureBuilder

`FutureBuilder` 根据 `Future` 的状态构建 UI。

#### 5.1.1 基本用法

```dart
class UserProfile extends StatelessWidget {
  final Future<User> userFuture;

  UserProfile({required this.userFuture});

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<User>(
      future: userFuture,
      builder: (context, snapshot) {
        // 检查连接状态
        switch (snapshot.connectionState) {
          case ConnectionState.none:
            return Text('Not started');
          case ConnectionState.waiting:
            return CircularProgressIndicator();
          case ConnectionState.active:
          case ConnectionState.done:
            if (snapshot.hasError) {
              return Text('Error: ${snapshot.error}');
            }
            if (snapshot.hasData) {
              return Text('User: ${snapshot.data!.name}');
            }
            return Text('No data');
        }
      },
    );
  }
}

class User {
  final String name;
  User(this.name);
}
```

#### 5.1.2 ConnectionState 详解

```dart
void main() {
  // ConnectionState 枚举值:
  // - none: 未开始（future 为 null）
  // - waiting: 等待中
  // - active: 活跃（仅 StreamBuilder）
  // - done: 完成
}
```

#### 5.1.3 AsyncSnapshot 属性

```dart
class FutureBuilderDemo extends StatelessWidget {
  final Future<String> future;

  FutureBuilderDemo({required this.future});

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<String>(
      future: future,
      builder: (context, snapshot) {
        // snapshot 属性:
        // - connectionState: 连接状态
        // - data: 数据（如果有）
        // - error: 错误（如果有）
        // - hasData: 是否有数据
        // - hasError: 是否有错误
        // - requireData: 获取数据（没有则抛出异常）

        if (snapshot.hasError) {
          return Text('Error: ${snapshot.error}');
        }

        if (snapshot.hasData) {
          return Text('Data: ${snapshot.data}');
        }

        return CircularProgressIndicator();
      },
    );
  }
}
```

### 5.2 StreamBuilder

`StreamBuilder` 根据 `Stream` 的事件构建 UI，可以响应多个事件。

#### 5.2.1 基本用法

```dart
class CounterWidget extends StatelessWidget {
  final Stream<int> counterStream;

  CounterWidget({required this.counterStream});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<int>(
      stream: counterStream,
      initialData: 0,  // 初始数据
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return Text('Error: ${snapshot.error}');
        }

        return Text(
          'Count: ${snapshot.data}',
          style: TextStyle(fontSize: 24),
        );
      },
    );
  }
}
```

#### 5.2.2 完整示例

```dart
class ChatScreen extends StatefulWidget {
  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final StreamController<Message> _messageController =
      StreamController<Message>.broadcast();
  final List<Message> _messages = [];

  @override
  void dispose() {
    _messageController.close();
    super.dispose();
  }

  void _sendMessage(String text) {
    final message = Message(
      text: text,
      timestamp: DateTime.now(),
      sender: 'Me',
    );
    _messageController.add(message);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Expanded(
          child: StreamBuilder<Message>(
            stream: _messageController.stream,
            builder: (context, snapshot) {
              if (snapshot.hasData) {
                _messages.add(snapshot.data!);
              }

              return ListView.builder(
                itemCount: _messages.length,
                itemBuilder: (context, index) {
                  return ListTile(
                    title: Text(_messages[index].text),
                    subtitle: Text(_messages[index].sender),
                  );
                },
              );
            },
          ),
        ),
        TextField(
          onSubmitted: _sendMessage,
        ),
      ],
    );
  }
}

class Message {
  final String text;
  final DateTime timestamp;
  final String sender;

  Message({
    required this.text,
    required this.timestamp,
    required this.sender,
  });
}
```

**Flutter 框架小知识**

FutureBuilder 和 StreamBuilder 的选择

| 特性     | FutureBuilder      | StreamBuilder                 |
| -------- | ------------------ | ----------------------------- |
| 数据源   | Future             | Stream                        |
| 数据量   | 单一结果           | 多个事件                      |
| 重建次数 | 一次               | 多次                          |
| 适用场景 | API 请求、文件读取 | 实时数据、用户输入、WebSocket |

```dart
// FutureBuilder 示例：加载用户资料
FutureBuilder<User>(
  future: api.fetchUser(userId),
  builder: (context, snapshot) => /* ... */,
)

// StreamBuilder 示例：实时位置更新
StreamBuilder<Location>(
  stream: locationService.locationStream,
  builder: (context, snapshot) => /* ... */,
)
```

## 第6章 实战应用示例

### 6.1 网络请求封装

```dart
import 'dart:convert';
import 'dart:io';

class ApiClient {
  final String baseUrl;
  final HttpClient _client = HttpClient();

  ApiClient({required this.baseUrl});

  Future<T> get<T>(
    String path, {
    required T Function(dynamic) parser,
    Map<String, String>? headers,
  }) async {
    try {
      final uri = Uri.parse('$baseUrl$path');
      final request = await _client.getUrl(uri);

      headers?.forEach((key, value) {
        request.headers.set(key, value);
      });

      final response = await request.close();

      if (response.statusCode == 200) {
        final body = await response.transform(utf8.decoder).join();
        return parser(jsonDecode(body));
      } else {
        throw HttpException('Status ${response.statusCode}');
      }
    } on SocketException {
      throw NetworkException('No internet connection');
    } on FormatException {
      throw ParseException('Invalid response format');
    }
  }

  Stream<T> paginated<T>(
    String path, {
    required T Function(dynamic) parser,
    int pageSize = 20,
  }) async* {
    int page = 1;
    bool hasMore = true;

    while (hasMore) {
      try {
        final data = await get(
          '$path?page=$page&size=$pageSize',
          parser: (json) => json,
        );

        final items = (data['items'] as List).map(parser);

        for (var item in items) {
          yield item;
        }

        hasMore = data['hasMore'] ?? false;
        page++;
      } catch (e) {
        yield* Stream.error(e);
        break;
      }
    }
  }
}

class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);
}

class ParseException implements Exception {
  final String message;
  ParseException(this.message);
}
```

### 6.2 防抖和节流

```dart
import 'dart:async';

// 防抖（Debounce）：延迟执行，如果在此期间有新事件，重新计时
Stream<T> debounce<T>(Stream<T> stream, Duration duration) {
  Timer? timer;

  return stream.asyncExpand((event) {
    timer?.cancel();

    return Stream.fromFuture(
      Future.delayed(duration, () => event),
    ).takeUntil(
      stream.skip(1).take(1),
    );
  });
}

// 更简洁的防抖实现
class Debouncer<T> {
  final Duration delay;
  Timer? _timer;
  final _controller = StreamController<T>.broadcast();

  Debouncer({required this.delay});

  Stream<T> get stream => _controller.stream;

  void add(T event) {
    _timer?.cancel();
    _timer = Timer(delay, () {
      _controller.add(event);
    });
  }

  void dispose() {
    _timer?.cancel();
    _controller.close();
  }
}

// 节流（Throttle）：限制执行频率
Stream<T> throttle<T>(Stream<T> stream, Duration duration) {
  DateTime? lastExecution;

  return stream.where((event) {
    final now = DateTime.now();
    if (lastExecution == null ||
        now.difference(lastExecution!) >= duration) {
      lastExecution = now;
      return true;
    }
    return false;
  });
}

// 节流器类
class Throttler<T> {
  final Duration interval;
  DateTime? _lastExecution;
  final _controller = StreamController<T>.broadcast();

  Throttler({required this.interval});

  Stream<T> get stream => _controller.stream;

  void add(T event) {
    final now = DateTime.now();
    if (_lastExecution == null ||
        now.difference(_lastExecution!) >= interval) {
      _lastExecution = now;
      _controller.add(event);
    }
  }

  void dispose() {
    _controller.close();
  }
}

// 使用示例
void main() {
  // 防抖：搜索输入
  final searchDebouncer = Debouncer<String>(delay: Duration(milliseconds: 500));

  searchDebouncer.stream.listen((query) {
    print('Searching for: $query');
  });

  // 模拟快速输入
  searchDebouncer.add('F');
  searchDebouncer.add('Fl');
  searchDebouncer.add('Flu');
  searchDebouncer.add('Flut');
  searchDebouncer.add('Flutter');  // 只有这个会触发搜索

  // 节流：按钮点击
  final buttonThrottler = Throttler<void>(interval: Duration(seconds: 2));

  buttonThrottler.stream.listen((_) {
    print('Button clicked!');
  });

  // 快速点击，每秒只执行一次
  buttonThrottler.add(null);
  buttonThrottler.add(null);  // 被忽略
  Future.delayed(Duration(seconds: 1), () => buttonThrottler.add(null));  // 被忽略
  Future.delayed(Duration(seconds: 2), () => buttonThrottler.add(null));  // 执行
}
```

### 6.3 状态管理（BLoC 模式简化版）

```dart
import 'dart:async';

// 事件基类
abstract class CounterEvent {}

class IncrementEvent extends CounterEvent {}
class DecrementEvent extends CounterEvent {}
class ResetEvent extends CounterEvent {}

// 状态类
class CounterState {
  final int count;
  final bool isLoading;
  final String? error;

  CounterState({
    this.count = 0,
    this.isLoading = false,
    this.error,
  });

  CounterState copyWith({
    int? count,
    bool? isLoading,
    String? error,
  }) {
    return CounterState(
      count: count ?? this.count,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

// BLoC
class CounterBloc {
  final _stateController = StreamController<CounterState>.broadcast();
  final _eventController = StreamController<CounterEvent>.broadcast();

  CounterState _currentState = CounterState();

  Stream<CounterState> get state => _stateController.stream;
  Sink<CounterEvent> get event => _eventController.sink;
  CounterState get currentState => _currentState;

  CounterBloc() {
    _eventController.stream.listen(_handleEvent);
  }

  void _handleEvent(CounterEvent event) async {
    if (event is IncrementEvent) {
      _emit(_currentState.copyWith(isLoading: true));

      // 模拟异步操作
      await Future.delayed(Duration(milliseconds: 500));

      _emit(_currentState.copyWith(
        count: _currentState.count + 1,
        isLoading: false,
      ));
    } else if (event is DecrementEvent) {
      _emit(_currentState.copyWith(
        count: _currentState.count - 1,
      ));
    } else if (event is ResetEvent) {
      _emit(CounterState());
    }
  }

  void _emit(CounterState state) {
    _currentState = state;
    _stateController.add(state);
  }

  void dispose() {
    _stateController.close();
    _eventController.close();
  }
}

// Flutter Widget 中使用
class CounterPage extends StatelessWidget {
  final CounterBloc bloc = CounterBloc();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Counter BLoC')),
      body: StreamBuilder<CounterState>(
        stream: bloc.state,
        initialData: bloc.currentState,
        builder: (context, snapshot) {
          final state = snapshot.data!;

          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                if (state.isLoading) CircularProgressIndicator(),
                Text('Count: ${state.count}', style: TextStyle(fontSize: 24)),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    ElevatedButton(
                      onPressed: () => bloc.event.add(DecrementEvent()),
                      child: Text('-'),
                    ),
                    SizedBox(width: 16),
                    ElevatedButton(
                      onPressed: () => bloc.event.add(IncrementEvent()),
                      child: Text('+'),
                    ),
                    SizedBox(width: 16),
                    ElevatedButton(
                      onPressed: () => bloc.event.add(ResetEvent()),
                      child: Text('Reset'),
                    ),
                  ],
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}
```

### 6.4 文件下载进度

```dart
import 'dart:async';
import 'dart:io';
import 'dart:typed_data';

class DownloadProgress {
  final int bytesReceived;
  final int totalBytes;
  final double progress;
  final DownloadStatus status;
  final String? error;

  DownloadProgress({
    required this.bytesReceived,
    required this.totalBytes,
    required this.status,
    this.error,
  }) : progress = totalBytes > 0 ? bytesReceived / totalBytes : 0;

  factory DownloadProgress.initial() => DownloadProgress(
    bytesReceived: 0,
    totalBytes: 0,
    status: DownloadStatus.pending,
  );
}

enum DownloadStatus { pending, downloading, completed, failed, cancelled }

class FileDownloader {
  final _progressController = StreamController<DownloadProgress>.broadcast();
  bool _cancelled = false;

  Stream<DownloadProgress> get progress => _progressController.stream;

  Future<File> download(
    String url,
    String savePath, {
    Map<String, String>? headers,
  }) async {
    _cancelled = false;

    try {
      _emit(DownloadProgress(
        bytesReceived: 0,
        totalBytes: 0,
        status: DownloadStatus.downloading,
      ));

      final httpClient = HttpClient();
      final request = await httpClient.getUrl(Uri.parse(url));

      headers?.forEach((key, value) {
        request.headers.set(key, value);
      });

      final response = await request.close();

      if (response.statusCode != 200) {
        throw HttpException('HTTP ${response.statusCode}');
      }

      final totalBytes = response.contentLength;
      var bytesReceived = 0;
      final chunks = <Uint8List>[];

      await for (var chunk in response) {
        if (_cancelled) {
          throw Exception('Download cancelled');
        }

        chunks.add(chunk);
        bytesReceived += chunk.length;

        _emit(DownloadProgress(
          bytesReceived: bytesReceived,
          totalBytes: totalBytes,
          status: DownloadStatus.downloading,
        ));
      }

      // 合并所有 chunks
      final bytes = Uint8List(bytesReceived);
      var offset = 0;
      for (var chunk in chunks) {
        bytes.setRange(offset, offset + chunk.length, chunk);
        offset += chunk.length;
      }

      // 保存文件
      final file = File(savePath);
      await file.writeAsBytes(bytes);

      _emit(DownloadProgress(
        bytesReceived: bytesReceived,
        totalBytes: totalBytes,
        status: DownloadStatus.completed,
      ));

      return file;
    } catch (e) {
      _emit(DownloadProgress(
        bytesReceived: 0,
        totalBytes: 0,
        status: DownloadStatus.failed,
        error: e.toString(),
      ));
      rethrow;
    }
  }

  void cancel() {
    _cancelled = true;
    _emit(DownloadProgress(
      bytesReceived: 0,
      totalBytes: 0,
      status: DownloadStatus.cancelled,
    ));
  }

  void _emit(DownloadProgress progress) {
    if (!_progressController.isClosed) {
      _progressController.add(progress);
    }
  }

  void dispose() {
    _progressController.close();
  }
}

// 使用示例
void main() async {
  final downloader = FileDownloader();

  // 监听进度
  downloader.progress.listen((progress) {
    final percentage = (progress.progress * 100).toStringAsFixed(1);
    print('Download: $percentage% (${progress.bytesReceived}/${progress.totalBytes})');
  });

  try {
    final file = await downloader.download(
      'https://example.com/file.zip',
      '/path/to/save/file.zip',
    );
    print('Downloaded to: ${file.path}');
  } catch (e) {
    print('Download failed: $e');
  } finally {
    downloader.dispose();
  }
}
```

## 附录：异步编程速查表

| 特性             | 语法/方法                       | 说明              |
| ---------------- | ------------------------------- | ----------------- |
| Future           | `Future<T>`                     | 单一异步结果      |
| async            | `async`                         | 标记异步函数      |
| await            | `await`                         | 等待异步操作完成  |
| then             | `.then((value) {})`             | Future 成功回调   |
| catchError       | `.catchError((error) {})`       | Future 错误处理   |
| whenComplete     | `.whenComplete(() {})`          | Future 完成回调   |
| Future.wait      | `Future.wait([f1, f2])`         | 等待多个 Future   |
| Future.any       | `Future.any([f1, f2])`          | 返回最快的 Future |
| Stream           | `Stream<T>`                     | 异步事件序列      |
| listen           | `.listen((data) {})`            | 订阅 Stream       |
| map              | `.map((e) => ...)`              | 转换元素          |
| where            | `.where((e) => ...)`            | 过滤元素          |
| take             | `.take(n)`                      | 取前 n 个         |
| skip             | `.skip(n)`                      | 跳过前 n 个       |
| reduce           | `.reduce((a, b) => ...)`        | 累积为单个值      |
| fold             | `.fold(initial, (a, b) => ...)` | 带初始值的累积    |
| async\*          | `async*`                        | 异步生成器        |
| yield            | `yield value`                   | 产生值            |
| yield\*          | `yield* stream`                 | 委托另一个流      |
| await for        | `await for (var e in stream)`   | 消费流            |
| StreamController | `StreamController<T>()`         | 流控制器          |
| broadcast        | `StreamController.broadcast()`  | 广播流            |
| FutureBuilder    | `FutureBuilder<T>()`            | Flutter Future UI |
| StreamBuilder    | `StreamBuilder<T>()`            | Flutter Stream UI |

---

本文档详细介绍了 Dart 语言的异步编程机制，从基础的 `Future` 和 `async/await` 到高级的 `Stream` 处理、转换和操作。掌握这些内容将帮助你编写出高效、响应式的 Dart 应用程序，特别是在 Flutter 开发中能够更好地处理网络请求、用户输入、状态管理等异步场景。
