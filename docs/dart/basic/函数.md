# Dart 语言函数详解

函数是 Dart 语言的核心构建块之一。作为一门真正的面向对象语言，Dart 中的函数是**一等公民（First-class citizens）**，这意味着函数可以像其他对象一样被赋值给变量、作为参数传递给其他函数、作为函数的返回值，甚至可以在运行时动态创建。本章将系统且全面地介绍 Dart 语言中的函数系统，从基础的函数定义到高级的闭包、高阶函数、生成器等特性，配合大量实例代码，帮助读者深入理解并熟练运用 Dart 的函数式编程能力。

## 第1章 函数基础

### 1.1 函数的定义

在 Dart 中，函数是一段实现特定功能的代码块。函数定义包括返回类型、函数名、参数列表和函数体。

#### 1.1.1 基本函数定义

```dart
// 基本函数定义
int add(int a, int b) {
  return a + b;
}

// 无返回值函数
void greet(String name) {
  print('Hello, $name!');
}

// 无参数函数
String getCurrentTime() {
  return DateTime.now().toString();
}

void main() {
  var sum = add(3, 5);
  print(sum);  // 输出: 8
  
  greet('Alice');  // 输出: Hello, Alice!
  
  print(getCurrentTime());  // 输出当前时间
}
```

#### 1.1.2 省略返回类型

Dart 支持类型推断，可以省略返回类型，但建议为公共 API 添加类型注解以提高代码可读性。

```dart
// 省略返回类型（不推荐用于公共 API）
add(a, b) {
  return a + b;
}

// 省略参数类型（不推荐）
greet(name) {
  print('Hello, $name!');
}

void main() {
  print(add(3, 5));  // 输出: 8
  greet('Bob');      // 输出: Hello, Bob!
}
```

### 1.2 箭头函数（Arrow Functions）

当函数体只包含一个表达式时，可以使用箭头函数语法 `=>` 进行简写。箭头函数会自动返回表达式的值。

```dart
// 普通函数
int multiply(int a, int b) {
  return a * b;
}

// 箭头函数
int multiplyArrow(int a, int b) => a * b;

// 更多示例
int square(int n) => n * n;
double circleArea(double radius) => 3.14159 * radius * radius;
String greet(String name) => 'Hello, $name!';

// 无返回值的箭头函数
void printMessage(String msg) => print(msg);

void main() {
  print(multiplyArrow(4, 5));     // 输出: 20
  print(square(6));                // 输出: 36
  print(circleArea(3));            // 输出: 28.27431
  print(greet('Charlie'));         // 输出: Hello, Charlie!
}
```

**Dart Tips 语法小贴士**

箭头函数与普通函数的区别

箭头函数 `=> expr` 是 `{ return expr; }` 的语法糖，两者完全等价。但箭头函数更简洁，特别适合作为回调函数传递给其他函数。

```dart
// 这两种写法等价
bool isPositive(int n) => n > 0;

bool isPositiveLong(int n) {
  return n > 0;
}

// 箭头函数常用于回调
var numbers = [1, 2, 3, 4, 5];
var evens = numbers.where((n) => n.isEven);  // 简洁
```

## 第2章 函数参数

Dart 提供了灵活多样的参数传递方式，包括必需位置参数、可选位置参数和命名参数。理解这些参数类型对于编写清晰、灵活的函数至关重要。

### 2.1 位置参数

位置参数是按照参数在函数定义中出现的顺序传递的参数。位置参数分为**必需位置参数**和**可选位置参数**。

#### 2.1.1 必需位置参数

必需位置参数是函数调用时必须提供的参数，按照定义的顺序传递。

```dart
// 必需位置参数
String formatName(String firstName, String lastName) {
  return '$lastName, $firstName';
}

void main() {
  print(formatName('John', 'Doe'));  // 输出: Doe, John
  // formatName('John');  // 错误: 缺少参数
}
```

#### 2.1.2 可选位置参数

可选位置参数使用方括号 `[]` 包裹，调用函数时可以不提供这些参数。如果没有提供值，参数默认为 `null`（除非指定了默认值）。

```dart
// 可选位置参数
String greet(String name, [String? greeting]) {
  if (greeting != null) {
    return '$greeting, $name!';
  }
  return 'Hello, $name!';
}

// 带默认值的可选位置参数
String buildMessage(String from, String msg, [String device = 'carrier pigeon']) {
  return '$from says $msg with a $device';
}

void main() {
  print(greet('Alice'));                    // 输出: Hello, Alice!
  print(greet('Bob', 'Good morning'));      // 输出: Good morning, Bob!
  
  print(buildMessage('Alice', 'Hello'));    // 输出: Alice says Hello with a carrier pigeon
  print(buildMessage('Bob', 'Hi', 'phone'));// 输出: Bob says Hi with a phone
}
```

**可选位置参数的注意事项**

```dart
// 可选位置参数必须放在必需参数之后
void example(String required, [String? optional1, int? optional2]) {
  print('Required: $required, Optional1: $optional1, Optional2: $optional2');
}

void main() {
  example('must');                    // 输出: Required: must, Optional1: null, Optional2: null
  example('must', 'optional');        // 输出: Required: must, Optional1: optional, Optional2: null
  example('must', 'optional', 42);    // 输出: Required: must, Optional1: optional, Optional2: 42
}
```

### 2.2 命名参数

命名参数使用花括号 `{}` 包裹，调用函数时需要指定参数名。命名参数使代码更具可读性，参数顺序不再重要。

#### 2.2.1 基本命名参数

```dart
// 命名参数
void enableFlags({bool? bold, bool? hidden}) {
  print('Bold: $bold, Hidden: $hidden');
}

void main() {
  // 调用时可以按任意顺序
  enableFlags(bold: true, hidden: false);   // 输出: Bold: true, Hidden: false
  enableFlags(hidden: false, bold: true);   // 输出: Bold: true, Hidden: false
  enableFlags(bold: true);                  // 输出: Bold: true, Hidden: null
  enableFlags();                            // 输出: Bold: null, Hidden: null
}
```

#### 2.2.2 带默认值的命名参数

```dart
// 带默认值的命名参数
void setConfig({
  String host = 'localhost',
  int port = 8080,
  bool useHttps = false,
}) {
  print('Config: host=$host, port=$port, https=$useHttps');
}

void main() {
  setConfig();                                          // 输出: Config: host=localhost, port=8080, https=false
  setConfig(host: 'example.com');                       // 输出: Config: host=example.com, port=8080, https=false
  setConfig(port: 3000, useHttps: true);                // 输出: Config: host=localhost, port=3000, https=true
  setConfig(host: 'api.example.com', port: 443, useHttps: true);
}
```

#### 2.2.3 必需命名参数（required）

使用 `required` 关键字可以将命名参数标记为必需，调用者必须提供该参数的值。

```dart
// 必需命名参数
class User {
  final String name;
  final int age;
  final String? email;
  
  User({
    required this.name,
    required this.age,
    this.email,
  });
}

// 函数中的必需命名参数
void createUser({
  required String name,
  required int age,
  String? email,
}) {
  print('Creating user: name=$name, age=$age, email=$email');
}

void main() {
  // createUser(name: 'Alice');  // 错误: 缺少必需参数 'age'
  
  createUser(name: 'Alice', age: 25);                           // 正确
  createUser(name: 'Bob', age: 30, email: 'bob@example.com');   // 正确
  
  var user = User(name: 'Charlie', age: 35);
  print(user.name);  // 输出: Charlie
}
```

### 2.3 参数组合使用

Dart 允许将必需位置参数、可选位置参数和命名参数组合使用，但需要遵循特定的顺序规则。

```dart
// 组合使用: 必需位置参数 + 命名参数
void function1(String required, {String? named1, int? named2}) {
  print('Required: $required, Named1: $named1, Named2: $named2');
}

// 组合使用: 必需位置参数 + 可选位置参数
void function2(String required, [String? optional1, int? optional2]) {
  print('Required: $required, Optional1: $optional1, Optional2: $optional2');
}

// 组合使用: 必需位置参数 + 可选位置参数 + 命名参数
void function3(
  String required1,
  String required2, [
  String? optional,
], {
  String? named1,
  int? named2,
}) {
  print('Req1: $required1, Req2: $required2, Opt: $optional, Named1: $named1, Named2: $named2');
}

void main() {
  function1('test', named1: 'value');
  function2('test', 'optional');
  function3('a', 'b', 'c', named1: 'd', named2: 42);
}
```

**参数顺序规则**

1. 必需位置参数必须在前
2. 可选位置参数（`[]`）和命名参数（`{}`）不能同时使用
3. 命名参数可以出现在参数列表的任何位置

```dart
// 错误: 不能同时使用可选位置参数和命名参数
// void wrong(String a, [String? b], {String? c}) {}

// 正确: 命名参数可以放在前面
void correct({String? named}, [String? optional]) {}
```

### 2.4 参数展开（Spread）

Dart 支持使用展开运算符 `...` 将集合中的元素作为参数传递。

```dart
// 位置参数展开
int sum(int a, int b, int c) => a + b + c;

// 命名参数展开（需要 Map）
void setPosition({required int x, required int y, int? z}) {
  print('Position: ($x, $y, $z)');
}

void main() {
  var numbers = [1, 2, 3];
  print(sum(...numbers));  // 输出: 6
  
  var position = {'x': 10, 'y': 20};
  setPosition(...position, z: 30);  // 输出: Position: (10, 20, 30)
}
```

## 第3章 函数作为一等公民

在 Dart 中，函数是对象，类型为 `Function`。这意味着函数可以：
- 赋值给变量
- 作为参数传递给其他函数
- 作为函数的返回值
- 存储在数据结构中

### 3.1 函数赋值给变量

```dart
// 将函数赋值给变量
int add(int a, int b) => a + b;

void main() {
  // 使用 Function 类型
  Function operation = add;
  print(operation(3, 4));  // 输出: 7
  
  // 使用具体的函数类型
  int Function(int, int) mathOp = add;
  print(mathOp(5, 6));  // 输出: 11
  
  // 匿名函数赋值给变量
  var multiply = (int a, int b) => a * b;
  print(multiply(4, 5));  // 输出: 20
  
  // 箭头函数
  var greet = (String name) => 'Hello, $name!';
  print(greet('Alice'));  // 输出: Hello, Alice!
}
```

### 3.2 函数作为参数

函数可以作为参数传递给其他函数，这是实现回调机制和函数式编程的基础。

```dart
// 接受函数作为参数
void processNumbers(
  List<int> numbers,
  void Function(int) action,
) {
  for (var number in numbers) {
    action(number);
  }
}

// 返回布尔值的函数参数
List<int> filter(
  List<int> numbers,
  bool Function(int) predicate,
) {
  var result = <int>[];
  for (var number in numbers) {
    if (predicate(number)) {
      result.add(number);
    }
  }
  return result;
}

void main() {
  var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // 传递命名函数
  processNumbers(numbers, print);
  
  // 传递匿名函数
  processNumbers(numbers, (n) => print('Number: $n'));
  
  // 过滤偶数
  var evens = filter(numbers, (n) => n.isEven);
  print(evens);  // 输出: [2, 4, 6, 8, 10]
  
  // 过滤大于5的数
  var greaterThanFive = filter(numbers, (n) => n > 5);
  print(greaterThanFive);  // 输出: [6, 7, 8, 9, 10]
}
```

### 3.3 函数作为返回值

函数可以作为另一个函数的返回值，这种技术常用于创建函数工厂和实现柯里化。

```dart
// 返回函数的函数（函数工厂）
int Function(int) createMultiplier(int factor) {
  return (int number) => number * factor;
}

// 柯里化示例
int Function(int) Function(int) addCurried(int a) {
  return (int b) => (int c) => a + b + c;
}

// 更复杂的函数工厂
String Function(String) createGreeter(String greeting) {
  return (String name) => '$greeting, $name!';
}

void main() {
  // 创建倍数函数
  var doubleIt = createMultiplier(2);
  var tripleIt = createMultiplier(3);
  
  print(doubleIt(5));  // 输出: 10
  print(tripleIt(4));  // 输出: 12
  
  // 柯里化调用
  var add5 = addCurried(5);
  var add5And3 = add5(3);
  print(add5And3(2));  // 输出: 10 (5 + 3 + 2)
  
  // 简写
  print(addCurried(1)(2)(3));  // 输出: 6
  
  // 创建问候函数
  var sayHello = createGreeter('Hello');
  var sayGoodbye = createGreeter('Goodbye');
  
  print(sayHello('Alice'));     // 输出: Hello, Alice!
  print(sayGoodbye('Bob'));     // 输出: Goodbye, Bob!
}
```

**Flutter 框架小知识**

函数作为回调在 Flutter 中的应用

在 Flutter 中，函数作为回调被广泛使用，特别是在处理用户交互时。

```dart
ElevatedButton(
  onPressed: () => print('Button pressed'),
  child: Text('Click Me'),
)

TextField(
  onChanged: (value) => print('Input: $value'),
)

ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) => ListTile(
    title: Text(items[index]),
  ),
)
```

## 第4章 匿名函数

匿名函数（也称为 lambda 表达式或闭包）是没有名称的函数，通常用于作为参数传递给其他函数或立即执行。

### 4.1 匿名函数语法

```dart
// 完整语法
(parameters) {
  // 函数体
  return value;
}

// 箭头语法（单表达式）
(parameters) => expression
```

### 4.2 匿名函数作为参数

```dart
void main() {
  var numbers = [1, 2, 3, 4, 5];
  
  // forEach 接受匿名函数
  numbers.forEach((number) {
    print('Number: $number');
  });
  
  // 使用箭头函数更简洁
  numbers.forEach((n) => print('Value: $n'));
  
  // map 使用匿名函数
  var squared = numbers.map((n) => n * n);
  print(squared.toList());  // 输出: [1, 4, 9, 16, 25]
  
  // where 使用匿名函数
  var evens = numbers.where((n) => n.isEven);
  print(evens.toList());  // 输出: [2, 4]
  
  // reduce 使用匿名函数
  var sum = numbers.reduce((a, b) => a + b);
  print(sum);  // 输出: 15
  
  // sort 使用匿名函数
  var fruits = ['banana', 'apple', 'cherry'];
  fruits.sort((a, b) => a.length.compareTo(b.length));
  print(fruits);  // 输出: [apple, banana, cherry]
}
```

### 4.3 立即执行函数（IIFE）

Dart 支持立即执行函数表达式（Immediately Invoked Function Expression）。

```dart
void main() {
  // 立即执行函数
  var result = (() {
    var a = 10;
    var b = 20;
    return a + b;
  })();
  print(result);  // 输出: 30
  
  // 带参数的立即执行函数
  var greeting = ((String name) => 'Hello, $name!')('Alice');
  print(greeting);  // 输出: Hello, Alice!
  
  // 创建私有作用域
  var counter = (() {
    var count = 0;
    return () => ++count;
  })();
  
  print(counter());  // 输出: 1
  print(counter());  // 输出: 2
  print(counter());  // 输出: 3
}
```

## 第5章 闭包（Closure）

闭包是一个函数对象，它可以访问其词法作用域中的变量，即使该函数在其原始作用域之外被调用。

### 5.1 闭包的基本概念

```dart
Function makeAdder(int addBy) {
  return (int i) => addBy + i;
}

void main() {
  // 创建两个闭包
  var add2 = makeAdder(2);
  var add5 = makeAdder(5);
  
  // 每个闭包都"记住"了它自己的 addBy 值
  print(add2(3));  // 输出: 5 (2 + 3)
  print(add2(10)); // 输出: 12 (2 + 10)
  
  print(add5(3));  // 输出: 8 (5 + 3)
  print(add5(10)); // 输出: 15 (5 + 10)
}
```

### 5.2 闭包捕获变量

闭包可以捕获并记住其词法作用域中的变量，即使外部函数已经返回。

```dart
Function createCounter() {
  var count = 0;  // 被闭包捕获的变量
  
  return () {
    count++;  // 闭包可以访问并修改 count
    return count;
  };
}

void main() {
  var counter1 = createCounter();
  var counter2 = createCounter();
  
  // counter1 和 counter2 各自维护独立的 count
  print(counter1());  // 输出: 1
  print(counter1());  // 输出: 2
  print(counter1());  // 输出: 3
  
  print(counter2());  // 输出: 1 (独立的计数器)
  print(counter2());  // 输出: 2
  
  print(counter1());  // 输出: 4 (counter1 继续计数)
}
```

### 5.3 闭包的实际应用

#### 5.3.1 数据隐藏和封装

```dart
class BankAccount {
  // 使用闭包实现私有状态
  late final void Function(double) _deposit;
  late final void Function(double) _withdraw;
  late final double Function() _getBalance;
  
  BankAccount(double initialBalance) {
    double balance = initialBalance;  // 被闭包捕获的私有变量
    
    _deposit = (amount) {
      if (amount > 0) {
        balance += amount;
        print('存入: \$$amount, 余额: \$$balance');
      }
    };
    
    _withdraw = (amount) {
      if (amount > 0 && amount <= balance) {
        balance -= amount;
        print('取出: \$$amount, 余额: \$$balance');
      } else {
        print('余额不足');
      }
    };
    
    _getBalance = () => balance;
  }
  
  void deposit(double amount) => _deposit(amount);
  void withdraw(double amount) => _withdraw(amount);
  double get balance => _getBalance();
}

void main() {
  var account = BankAccount(1000);
  account.deposit(500);   // 输出: 存入: $500, 余额: $1500
  account.withdraw(300);  // 输出: 取出: $300, 余额: $1200
  print('当前余额: \$${account.balance}');  // 输出: 当前余额: $1200
}
```

#### 5.3.2 函数记忆化（Memoization）

```dart
// 使用闭包实现函数记忆化
Function memoize(Function func) {
  final cache = <dynamic, dynamic>{};
  
  return (dynamic arg) {
    if (cache.containsKey(arg)) {
      print('从缓存获取: $arg');
      return cache[arg];
    }
    
    print('计算: $arg');
    var result = func(arg);
    cache[arg] = result;
    return result;
  };
}

// 递归斐波那契（带记忆化）
Function createFibonacci() {
  late final Function(int) fib;
  final cache = <int, int>{0: 0, 1: 1};
  
  fib = (int n) {
    if (cache.containsKey(n)) {
      return cache[n]!;
    }
    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n]!;
  };
  
  return fib;
}

void main() {
  // 记忆化示例
  var slowFunction = (int n) {
    // 模拟耗时计算
    for (var i = 0; i < 1000000; i++) {}
    return n * n;
  };
  
  var memoized = memoize(slowFunction);
  
  print(memoized(5));  // 计算: 5, 输出: 25
  print(memoized(5));  // 从缓存获取: 5, 输出: 25
  print(memoized(10)); // 计算: 10, 输出: 100
  
  // 斐波那契
  var fib = createFibonacci();
  print(fib(10));  // 输出: 55
  print(fib(50));  // 输出: 12586269025 (很快，因为有缓存)
}
```

**Dart Tips 语法小贴士**

闭包与内存管理

闭包会捕获其词法作用域中的变量，这可能导致内存泄漏，特别是在 Flutter 中处理回调时。当闭包被长期持有（如作为事件监听器），它会阻止被捕获的对象被垃圾回收。

```dart
// 潜在内存泄漏
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  String _data = 'sensitive data';
  
  @override
  void initState() {
    super.initState();
    // 危险: 这个闭包捕获了整个 State 对象
    someService.addListener(() {
      print(_data);  // 即使 widget 被销毁，闭包仍持有 State 引用
    });
  }
}

// 解决方案: 使用弱引用或及时取消监听
class _MyWidgetState extends State<MyWidget> {
  String _data = 'sensitive data';
  VoidCallback? _listener;
  
  @override
  void initState() {
    super.initState();
    _listener = () {
      if (mounted) {
        print(_data);
      }
    };
    someService.addListener(_listener!);
  }
  
  @override
  void dispose() {
    someService.removeListener(_listener!);
    super.dispose();
  }
}
```

## 第6章 高阶函数

高阶函数是指接受函数作为参数或返回函数的函数。Dart 提供了丰富的内置高阶函数，特别是在集合操作中。

### 6.1 内置高阶函数

#### 6.1.1 map

将集合中的每个元素转换为新的值，返回一个新的 Iterable。

```dart
void main() {
  var numbers = [1, 2, 3, 4, 5];
  
  // 基本用法
  var doubled = numbers.map((n) => n * 2);
  print(doubled.toList());  // 输出: [2, 4, 6, 8, 10]
  
  // 类型转换
  var strings = numbers.map((n) => 'Number $n');
  print(strings.toList());  // 输出: [Number 1, Number 2, Number 3, Number 4, Number 5]
  
  // 索引映射
  var indexed = numbers.asMap().entries.map((e) => '${e.key}: ${e.value}');
  print(indexed.toList());  // 输出: [0: 1, 1: 2, 2: 3, 3: 4, 4: 5]
  
  // 链式调用
  var result = numbers
    .map((n) => n * n)
    .map((n) => n.toString().padLeft(3, '0'));
  print(result.toList());  // 输出: [001, 004, 009, 016, 025]
}
```

#### 6.1.2 where

过滤集合，只保留满足条件的元素。

```dart
void main() {
  var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // 过滤偶数
  var evens = numbers.where((n) => n.isEven);
  print(evens.toList());  // 输出: [2, 4, 6, 8, 10]
  
  // 过滤大于5的数
  var greaterThanFive = numbers.where((n) => n > 5);
  print(greaterThanFive.toList());  // 输出: [6, 7, 8, 9, 10]
  
  // 字符串过滤
  var words = ['apple', 'banana', 'apricot', 'cherry', 'avocado'];
  var aWords = words.where((w) => w.startsWith('a'));
  print(aWords.toList());  // 输出: [apple, apricot, avocado]
  
  // 复合条件
  var complex = numbers.where((n) => n > 3 && n.isOdd);
  print(complex.toList());  // 输出: [5, 7, 9]
}
```

#### 6.1.3 reduce 和 fold

`reduce` 将集合中的元素累积为一个值。`fold` 与 `reduce` 类似，但可以指定初始值。

```dart
void main() {
  var numbers = [1, 2, 3, 4, 5];
  
  // reduce: 求和
  var sum = numbers.reduce((a, b) => a + b);
  print(sum);  // 输出: 15
  
  // reduce: 求最大值
  var max = numbers.reduce((a, b) => a > b ? a : b);
  print(max);  // 输出: 5
  
  // fold: 带初始值的求和
  var sumWithInitial = numbers.fold<int>(10, (prev, curr) => prev + curr);
  print(sumWithInitial);  // 输出: 25 (10 + 1 + 2 + 3 + 4 + 5)
  
  // fold: 字符串连接
  var words = ['Hello', 'Dart', 'World'];
  var sentence = words.fold<String>(
    '',
    (prev, curr) => prev.isEmpty ? curr : '$prev $curr',
  );
  print(sentence);  // 输出: Hello Dart World
  
  // fold: 构建 Map
  var entries = [('a', 1), ('b', 2), ('c', 3)];
  var map = entries.fold<Map<String, int>>(
    {},
    (prev, curr) => prev..[curr.$1] = curr.$2,
  );
  print(map);  // 输出: {a: 1, b: 2, c: 3}
}
```

#### 6.1.4 expand

将每个元素展开为零个或多个元素。

```dart
void main() {
  var nested = [[1, 2], [3, 4], [5, 6]];
  
  // 扁平化嵌套列表
  var flattened = nested.expand((list) => list);
  print(flattened.toList());  // 输出: [1, 2, 3, 4, 5, 6]
  
  // 生成多个元素
  var numbers = [1, 2, 3];
  var repeated = numbers.expand((n) => [n, n, n]);
  print(repeated.toList());  // 输出: [1, 1, 1, 2, 2, 2, 3, 3, 3]
  
  // 过滤并展开
  var words = ['hello', 'hi', 'hey'];
  var chars = words.expand((w) => w.length > 3 ? w.split('') : []);
  print(chars.toList());  // 输出: [h, e, l, l, o]
}
```

#### 6.1.5 take、skip 和 takeWhile、skipWhile

```dart
void main() {
  var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // take: 取前 n 个元素
  print(numbers.take(3).toList());  // 输出: [1, 2, 3]
  
  // skip: 跳过前 n 个元素
  print(numbers.skip(7).toList());  // 输出: [8, 9, 10]
  
  // takeWhile: 取元素直到条件不满足
  print(numbers.takeWhile((n) => n < 5).toList());  // 输出: [1, 2, 3, 4]
  
  // skipWhile: 跳过元素直到条件不满足
  print(numbers.skipWhile((n) => n < 5).toList());  // 输出: [5, 6, 7, 8, 9, 10]
  
  // 组合使用
  print(numbers.skip(2).take(3).toList());  // 输出: [3, 4, 5]
}
```

#### 6.1.6 any 和 every

```dart
void main() {
  var numbers = [2, 4, 6, 8, 10];
  
  // any: 是否有至少一个元素满足条件
  print(numbers.any((n) => n > 5));   // 输出: true
  print(numbers.any((n) => n > 10));  // 输出: false
  
  // every: 是否所有元素都满足条件
  print(numbers.every((n) => n.isEven));  // 输出: true
  print(numbers.every((n) => n > 5));     // 输出: false
  
  // 实际应用: 验证输入
  var passwords = ['abc123', 'def456', 'ghi789'];
  bool hasLongPassword = passwords.any((p) => p.length >= 8);
  bool allHaveNumbers = passwords.every((p) => p.contains(RegExp(r'\d')));
  
  print('有长密码: $hasLongPassword');    // 输出: false
  print('都有数字: $allHaveNumbers');     // 输出: true
}
```

#### 6.1.7 firstWhere、lastWhere 和 singleWhere

```dart
void main() {
  var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // firstWhere: 第一个满足条件的元素
  var firstEven = numbers.firstWhere((n) => n.isEven);
  print(firstEven);  // 输出: 2
  
  // lastWhere: 最后一个满足条件的元素
  var lastEven = numbers.lastWhere((n) => n.isEven);
  print(lastEven);  // 输出: 10
  
  // 带默认值
  var firstLarge = numbers.firstWhere(
    (n) => n > 100,
    orElse: () => -1,
  );
  print(firstLarge);  // 输出: -1
  
  // singleWhere: 唯一满足条件的元素（多于一个会报错）
  var single = numbers.singleWhere((n) => n == 5);
  print(single);  // 输出: 5
  
  // singleWhere 带 orElse
  var notFound = numbers.singleWhere(
    (n) => n > 100,
    orElse: () => -1,
  );
  print(notFound);  // 输出: -1
}
```

### 6.2 自定义高阶函数

```dart
// 函数组合
T Function(S) compose<T, S, R>(
  T Function(R) f,
  R Function(S) g,
) {
  return (x) => f(g(x));
}

// 管道操作
extension PipeExtension<T> on T {
  R pipe<R>(R Function(T) f) => f(this);
}

// 柯里化
R Function(B) Function(A) curry<A, B, R>(R Function(A, B) f) {
  return (a) => (b) => f(a, b);
}

// 偏应用
R Function(B) partial<A, B, R>(R Function(A, B) f, A a) {
  return (b) => f(a, b);
}

void main() {
  // 函数组合
  var add1 = (int x) => x + 1;
  var doubleIt = (int x) => x * 2;
  var add1ThenDouble = compose(doubleIt, add1);
  
  print(add1ThenDouble(5));  // 输出: 12 ((5 + 1) * 2)
  
  // 管道操作
  var result = 5
    .pipe((x) => x + 1)
    .pipe((x) => x * 2)
    .pipe((x) => x - 3);
  print(result);  // 输出: 9
  
  // 柯里化
  var add = curry<int, int, int>((a, b) => a + b);
  var add5 = add(5);
  print(add5(3));  // 输出: 8
  
  // 偏应用
  var greet = (String greeting, String name) => '$greeting, $name!';
  var sayHello = partial(greet, 'Hello');
  print(sayHello('Alice'));  // 输出: Hello, Alice!
}
```

## 第7章 函数类型与 typedef

### 7.1 函数类型语法

Dart 使用 `返回类型 Function(参数类型)` 语法来表示函数类型。

```dart
// 基本函数类型
int Function(int, int) binaryOperation;
void Function(String) stringCallback;
bool Function(int) predicate;

// 命名参数的函数类型
void Function({required String name, int? age}) namedParams;

// 可选位置参数的函数类型
String Function(String, [int?]) optionalParams;

void main() {
  // 赋值
  binaryOperation = (a, b) => a + b;
  print(binaryOperation(3, 4));  // 输出: 7
  
  // 作为参数类型
  void execute(int Function(int, int) op, int a, int b) {
    print(op(a, b));
  }
  
  execute((x, y) => x * y, 5, 6);  // 输出: 30
}
```

### 7.2 typedef 定义函数类型别名

`typedef` 用于为函数类型创建别名，提高代码可读性和可维护性。

```dart
// 定义函数类型别名
typedef BinaryOperation = int Function(int, int);
typedef Predicate<T> = bool Function(T);
typedef Callback<T> = void Function(T);
typedef Mapper<T, R> = R Function(T);
typedef Comparator<T> = int Function(T, T);

// 使用 typedef
int calculate(BinaryOperation op, int a, int b) {
  return op(a, b);
}

List<T> filter<T>(List<T> items, Predicate<T> predicate) {
  return items.where(predicate).toList();
}

void processItems<T>(List<T> items, Callback<T> callback) {
  for (var item in items) {
    callback(item);
  }
}

List<R> mapItems<T, R>(List<T> items, Mapper<T, R> mapper) {
  return items.map(mapper).toList();
}

void main() {
  // 使用 BinaryOperation
  var sum = calculate((a, b) => a + b, 10, 20);
  print(sum);  // 输出: 30
  
  // 使用 Predicate
  var numbers = [1, 2, 3, 4, 5, 6];
  var evens = filter(numbers, (n) => n.isEven);
  print(evens);  // 输出: [2, 4, 6]
  
  // 使用 Callback
  processItems(['Alice', 'Bob', 'Charlie'], (name) {
    print('Hello, $name!');
  });
  
  // 使用 Mapper
  var names = ['Alice', 'Bob'];
  var lengths = mapItems(names, (name) => name.length);
  print(lengths);  // 输出: [5, 3]
}
```

### 7.3 typedef 与类结合

```dart
// 回调类型定义
typedef ValueChanged<T> = void Function(T value);
typedef VoidCallback = void Function();
typyped AsyncCallback = Future<void> Function();

// 在类中使用
typedef ValidationFunc<T> = String? Function(T value);

class FormField<T> {
  final String label;
  final ValidationFunc<T>? validator;
  final ValueChanged<T>? onChanged;
  
  FormField({
    required this.label,
    this.validator,
    this.onChanged,
  });
  
  String? validate(T value) {
    return validator?.call(value);
  }
}

void main() {
  var emailField = FormField<String>(
    label: 'Email',
    validator: (value) {
      if (value == null || value.isEmpty) {
        return 'Email is required';
      }
      if (!value.contains('@')) {
        return 'Invalid email format';
      }
      return null;
    },
    onChanged: (value) => print('Email changed: $value'),
  );
  
  print(emailField.validate(''));        // 输出: Email is required
  print(emailField.validate('invalid')); // 输出: Invalid email format
  print(emailField.validate('a@b.com')); // 输出: null
}
```

**Flutter 框架小知识**

Flutter 中常用的 typedef

Flutter 框架定义了许多常用的回调类型：

```dart
// 值变化回调
typedef ValueChanged<T> = void Function(T value);

// 无参数回调
typedef VoidCallback = void Function();

// 构建器回调
typedef WidgetBuilder = Widget Function(BuildContext context);
typedef IndexedWidgetBuilder = Widget Function(BuildContext context, int index);

// 使用示例
TextField(
  onChanged: (value) => print('Changed: $value'),  // ValueChanged<String>
)

ElevatedButton(
  onPressed: () => print('Pressed'),  // VoidCallback
  child: Text('Click'),
)

ListView.builder(
  itemBuilder: (context, index) => ListTile(title: Text('Item $index')),  // IndexedWidgetBuilder
)
```

## 第8章 回调函数

回调函数是 Dart 中处理异步操作和事件驱动编程的重要机制。

### 8.1 同步回调

```dart
// 数据处理回调
typedef DataProcessor<T> = T Function(T data);
typedef ErrorHandler = void Function(String error);

T processData<T>(
  T data,
  DataProcessor<T> processor, {
  ErrorHandler? onError,
}) {
  try {
    return processor(data);
  } catch (e) {
    onError?.call(e.toString());
    rethrow;
  }
}

void main() {
  // 基本回调
  var result = processData(
    10,
    (n) => n * n,
  );
  print(result);  // 输出: 100
  
  // 带错误处理的回调
  var riskyResult = processData(
    10,
    (n) => n ~/ 0,  // 除以零
    onError: (error) => print('Error occurred: $error'),
  );
}
```

### 8.2 异步回调

```dart
// 异步回调类型
typedef SuccessCallback<T> = void Function(T data);
typedef FailureCallback = void Function(Exception error);
typedef ProgressCallback = void Function(double progress);

Future<void> fetchData<T>({
  required Future<T> Function() fetcher,
  required SuccessCallback<T> onSuccess,
  FailureCallback? onFailure,
  ProgressCallback? onProgress,
}) async {
  try {
    onProgress?.call(0.0);
    
    await Future.delayed(Duration(seconds: 1));
    onProgress?.call(0.5);
    
    var data = await fetcher();
    onProgress?.call(1.0);
    
    onSuccess(data);
  } catch (e) {
    onFailure?.call(e as Exception);
  }
}

void main() async {
  await fetchData<String>(
    fetcher: () async => 'Fetched data',
    onSuccess: (data) => print('Success: $data'),
    onFailure: (error) => print('Failure: $error'),
    onProgress: (progress) => print('Progress: ${(progress * 100).toInt()}%'),
  );
}
```

### 8.3 事件监听回调

```dart
// 事件类型
typedef EventListener<T> = void Function(T event);

class EventBus<T> {
  final _listeners = <EventListener<T>>[];
  
  // 注册监听器
  void on(EventListener<T> listener) {
    _listeners.add(listener);
  }
  
  // 取消注册
  void off(EventListener<T> listener) {
    _listeners.remove(listener);
  }
  
  // 触发事件
  void emit(T event) {
    for (var listener in _listeners) {
      listener(event);
    }
  }
  
  // 只监听一次
  void once(EventListener<T> listener) {
    late EventListener<T> wrapper;
    wrapper = (event) {
      off(wrapper);
      listener(event);
    };
    on(wrapper);
  }
}

void main() {
  var eventBus = EventBus<String>();
  
  // 注册多个监听器
  eventBus.on((event) => print('Listener 1: $event'));
  eventBus.on((event) => print('Listener 2: $event'));
  
  // 只监听一次
  eventBus.once((event) => print('Once: $event'));
  
  // 触发事件
  eventBus.emit('Hello');  // 所有监听器都会收到
  eventBus.emit('World');  // once 监听器不会再收到
}
```

## 第9章 生成器函数

生成器函数是一种特殊的函数，它可以惰性地生成一系列值，而不是一次性计算所有值。

### 9.1 同步生成器（sync*）

使用 `sync*` 和 `yield` 创建同步生成器，返回一个 `Iterable`。

```dart
// 基本同步生成器
Iterable<int> naturalsTo(int n) sync* {
  var k = 0;
  while (k < n) {
    yield k++;
  }
}

// 递归生成器
Iterable<int> fibonacci() sync* {
  var a = 0;
  var b = 1;
  
  while (true) {
    yield a;
    var temp = a;
    a = b;
    b = temp + b;
  }
}

// 使用 yield* 委托给另一个生成器
Iterable<int> evenNumbers(int n) sync* {
  for (var i = 0; i < n; i++) {
    if (i.isEven) {
      yield i;
    }
  }
}

Iterable<int> doubledEvens(int n) sync* {
  yield* evenNumbers(n).map((e) => e * 2);
}

void main() {
  // 基本生成器
  print(naturalsTo(5).toList());  // 输出: [0, 1, 2, 3, 4]
  
  // 无限序列（惰性求值）
  print(fibonacci().take(10).toList());  // 输出: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
  
  // 委托生成器
  print(doubledEvens(10).toList());  // 输出: [0, 4, 8, 12, 16]
  
  // 惰性求值的优势
  var largeSequence = naturalsTo(1000000);
  print(largeSequence.first);  // 立即返回，不计算所有值
  print(largeSequence.take(5).toList());  // 只计算前5个值
}
```

### 9.2 异步生成器（async*）

使用 `async*` 和 `yield` 创建异步生成器，返回一个 `Stream`。

```dart
// 基本异步生成器
Stream<int> timedCounter(int interval, int maxCount) async* {
  for (var i = 1; i <= maxCount; i++) {
    await Future.delayed(Duration(milliseconds: interval));
    yield i;
  }
}

// 从 Stream 转换
Stream<String> messages(Stream<int> numbers) async* {
  await for (var n in numbers) {
    yield 'Message $n';
  }
}

// 使用 yield* 委托
Stream<int> combinedStream() async* {
  yield* Stream.fromIterable([1, 2, 3]);
  yield* Stream.fromIterable([4, 5, 6]);
}

// 带错误处理的异步生成器
Stream<int> safeCounter(int count) async* {
  try {
    for (var i = 0; i < count; i++) {
      if (i == 5) throw Exception('Error at 5');
      yield i;
    }
  } catch (e) {
    yield -1;  // 错误标记
    rethrow;
  }
}

void main() async {
  // 基本异步生成器
  await for (var count in timedCounter(100, 5)) {
    print('Count: $count');
  }
  
  // 转换 Stream
  var numbers = Stream.fromIterable([1, 2, 3]);
  await for (var msg in messages(numbers)) {
    print(msg);
  }
  
  // 组合 Stream
  await for (var value in combinedStream()) {
    print(value);  // 输出: 1, 2, 3, 4, 5, 6
  }
}
```

### 9.3 生成器的实际应用

```dart
// 分页数据生成器
Stream<List<T>> paginatedData<T>(
  Future<List<T>> Function(int page) fetchPage,
  int totalPages,
) async* {
  for (var page = 0; page < totalPages; page++) {
    var data = await fetchPage(page);
    if (data.isEmpty) break;
    yield data;
  }
}

// 文件行读取生成器
Stream<String> readLines(String filePath) async* {
  // 模拟文件读取
  var lines = [
    'Line 1',
    'Line 2',
    'Line 3',
  ];
  
  for (var line in lines) {
    await Future.delayed(Duration(milliseconds: 100));
    yield line;
  }
}

// 树结构遍历生成器
class TreeNode<T> {
  final T value;
  final List<TreeNode<T>> children;
  
  TreeNode(this.value, [this.children = const []]);
}

Iterable<T> traverseDFS<T>(TreeNode<T> node) sync* {
  yield node.value;
  for (var child in node.children) {
    yield* traverseDFS(child);
  }
}

Iterable<T> traverseBFS<T>(TreeNode<T> root) sync* {
  var queue = [root];
  
  while (queue.isNotEmpty) {
    var node = queue.removeAt(0);
    yield node.value;
    queue.addAll(node.children);
  }
}

void main() async {
  // 树遍历
  var tree = TreeNode('A', [
    TreeNode('B', [
      TreeNode('D'),
      TreeNode('E'),
    ]),
    TreeNode('C', [
      TreeNode('F'),
    ]),
  ]);
  
  print('DFS: ${traverseDFS(tree).toList()}');  // 输出: [A, B, D, E, C, F]
  print('BFS: ${traverseBFS(tree).toList()}');  // 输出: [A, B, C, D, E, F]
}
```

## 第10章 Tear-offs

Tear-offs 是 Dart 2.15+ 引入的特性，允许直接引用方法作为函数，而无需包装在匿名函数中。

### 10.1 方法 Tear-offs

```dart
class Person {
  final String name;
  final int age;
  
  Person(this.name, this.age);
  
  void introduce() {
    print('我是$name，今年$age岁');
  }
  
  String greet(String other) {
    return '$name 向 $other 问好';
  }
}

void main() {
  var people = [
    Person('Alice', 25),
    Person('Bob', 30),
    Person('Charlie', 35),
  ];
  
  // 以前: 使用匿名函数
  people.forEach((p) => p.introduce());
  
  // 现在: 使用 tear-off
  people.forEach(Person.introduce);  // 等效于 (p) => p.introduce()
  
  // 命名构造函数 tear-off
  var createPerson = Person.new;
  var person = createPerson('David', 40);
  print(person.name);  // 输出: David
  
  // 方法 tear-off 作为参数
  var greetings = people.map((p) => p.greet('大家')).toList();
  // 或使用 tear-off（需要额外的参数处理）
}
```

### 10.2 构造函数 Tear-offs

```dart
class User {
  final String name;
  final int age;
  
  User(this.name, this.age);
  
  User.guest() : name = 'Guest', age = 0;
  
  User.fromJson(Map<String, dynamic> json)
      : name = json['name'],
        age = json['age'];
}

void main() {
  // 默认构造函数 tear-off
  User Function(String, int) createUser = User.new;
  var user1 = createUser('Alice', 25);
  
  // 命名构造函数 tear-off
  User Function() createGuest = User.guest;
  var user2 = createGuest();
  
  // 带参数的命名构造函数 tear-off
  User Function(Map<String, dynamic>) fromJson = User.fromJson;
  var user3 = fromJson({'name': 'Bob', 'age': 30});
  
  print('${user1.name}, ${user2.name}, ${user3.name}');
  // 输出: Alice, Guest, Bob
}
```

### 10.3 泛型构造函数 Tear-offs

```dart
class Box<T> {
  final T value;
  
  Box(this.value);
}

void main() {
  // 泛型构造函数 tear-off
  Box<int> Function(int) intBox = Box<int>.new;
  Box<String> Function(String) stringBox = Box<String>.new;
  
  var intBoxInstance = intBox(42);
  var stringBoxInstance = stringBox('Hello');
  
  print(intBoxInstance.value);     // 输出: 42
  print(stringBoxInstance.value);  // 输出: Hello
}
```

### 10.4 与集合操作结合

```dart
class Product {
  final String name;
  final double price;
  
  Product(this.name, this.price);
  
  @override
  String toString() => '$name: \$$price';
}

void main() {
  var data = [
    {'name': 'Apple', 'price': 1.5},
    {'name': 'Banana', 'price': 0.8},
    {'name': 'Cherry', 'price': 2.0},
  ];
  
  // 使用构造函数 tear-off 创建对象列表
  var products = data.map(Product.new).toList();
  print(products);  // 输出: [Apple: $1.5, Banana: $0.8, Cherry: $2.0]
  
  // 使用 tear-off 进行排序
  products.sort((a, b) => a.name.compareTo(b.name));  // 传统方式
  // 或使用扩展方法
}
```

## 第11章 词法作用域与变量捕获

### 11.1 词法作用域

Dart 使用词法作用域，变量的作用范围由代码结构决定，而不是运行时调用栈。

```dart
var globalVar = 'global';

void outer() {
  var outerVar = 'outer';
  
  void middle() {
    var middleVar = 'middle';
    
    void inner() {
      var innerVar = 'inner';
      
      // 可以访问所有外层变量
      print(globalVar);   // 输出: global
      print(outerVar);    // 输出: outer
      print(middleVar);   // 输出: middle
      print(innerVar);    // 输出: inner
    }
    
    inner();
    // print(innerVar);  // 错误: innerVar 未定义
  }
  
  middle();
  // print(middleVar);  // 错误: middleVar 未定义
}

void main() {
  outer();
  // print(outerVar);  // 错误: outerVar 未定义
}
```

### 11.2 变量遮蔽（Shadowing）

内层作用域可以声明与外层同名的变量，这会遮蔽外层变量。

```dart
var name = 'global';

void example() {
  var name = 'outer';  // 遮蔽全局变量
  
  void nested() {
    var name = 'inner';  // 遮蔽外层变量
    print(name);  // 输出: inner
  }
  
  nested();
  print(name);  // 输出: outer
}

void main() {
  example();
  print(name);  // 输出: global
}
```

### 11.3 闭包中的变量捕获

闭包会捕获其词法作用域中的变量，即使外部函数已经返回。

```dart
List<Function> createCounters(int n) {
  var counters = <Function>[];
  
  for (var i = 0; i < n; i++) {
    // 每个闭包捕获自己的 i 值
    var captured = i;  // 显式捕获当前值
    counters.add(() => captured);
  }
  
  return counters;
}

void main() {
  var counters = createCounters(5);
  
  for (var counter in counters) {
    print(counter());  // 输出: 0, 1, 2, 3, 4
  }
}
```

## 第12章 函数相等性测试

### 12.1 顶级函数和静态方法

顶级函数和静态方法是恒等的，可以使用 `==` 或 `identical` 进行比较。

```dart
void globalFunction() {}

class MyClass {
  static void staticMethod() {}
  void instanceMethod() {}
}

void main() {
  // 顶级函数相等性
  print(globalFunction == globalFunction);  // 输出: true
  
  // 静态方法相等性
  print(MyClass.staticMethod == MyClass.staticMethod);  // 输出: true
  
  // 实例方法相等性（不同实例）
  var obj1 = MyClass();
  var obj2 = MyClass();
  print(obj1.instanceMethod == obj2.instanceMethod);  // 输出: false
  
  // 同一实例的方法相等性
  print(obj1.instanceMethod == obj1.instanceMethod);  // 输出: true
}
```

### 12.2 匿名函数相等性

每次创建匿名函数都会生成新的函数对象。

```dart
void main() {
  var func1 = () => 42;
  var func2 = () => 42;
  
  print(func1 == func2);      // 输出: false
  print(identical(func1, func2));  // 输出: false
  
  // 同一引用相等
  var func3 = func1;
  print(func1 == func3);      // 输出: true
}
```

## 第13章 实战应用示例

### 13.1 函数式状态管理

```dart
// 状态类型
typedef State<S, A> = (S Function(A), S);

// 纯函数状态转换
class CounterState {
  final int count;
  
  const CounterState(this.count);
  
  CounterState increment() => CounterState(count + 1);
  CounterState decrement() => CounterState(count - 1);
  CounterState add(int value) => CounterState(count + value);
}

// 使用高阶函数创建状态管理器
class Store<S> {
  S _state;
  final _listeners = <void Function(S)>[];
  
  Store(this._state);
  
  S get state => _state;
  
  void dispatch(S Function(S) reducer) {
    _state = reducer(_state);
    _notify();
  }
  
  void subscribe(void Function(S) listener) {
    _listeners.add(listener);
  }
  
  void _notify() {
    for (var listener in _listeners) {
      listener(_state);
    }
  }
}

void main() {
  var store = Store<CounterState>(CounterState(0));
  
  store.subscribe((state) => print('Count: ${state.count}'));
  
  store.dispatch((s) => s.increment());  // 输出: Count: 1
  store.dispatch((s) => s.increment());  // 输出: Count: 2
  store.dispatch((s) => s.add(5));       // 输出: Count: 7
}
```

### 13.2 函数式验证器

```dart
// 验证器类型
typedef Validator<T> = String? Function(T value);

// 验证器组合
Validator<T> combine<T>(List<Validator<T>> validators) {
  return (value) {
    for (var validator in validators) {
      var result = validator(value);
      if (result != null) return result;
    }
    return null;
  };
}

// 预定义验证器
class Validators {
  static Validator<String> required([String message = 'This field is required']) {
    return (value) => value?.isNotEmpty == true ? null : message;
  }
  
  static Validator<String> minLength(int length, [String? message]) {
    return (value) {
      if (value == null || value.length < length) {
        return message ?? 'Minimum length is $length';
      }
      return null;
    };
  }
  
  static Validator<String> email([String message = 'Invalid email']) {
    return (value) {
      if (value == null) return message;
      var regex = RegExp(r'^[\w\.-]+@[\w\.-]+\.\w+$');
      return regex.hasMatch(value) ? null : message;
    };
  }
  
  static Validator<String> pattern(RegExp regex, String message) {
    return (value) => value != null && regex.hasMatch(value) ? null : message;
  }
  
  static Validator<T> custom<T>(bool Function(T) test, String message) {
    return (value) => test(value) ? null : message;
  }
}

void main() {
  // 创建复合验证器
  var emailValidator = combine<String>([
    Validators.required(),
    Validators.email(),
  ]);
  
  var passwordValidator = combine<String>([
    Validators.required(),
    Validators.minLength(8),
    Validators.pattern(
      RegExp(r'^(?=.*[A-Za-z])(?=.*\d)'),
      'Must contain letters and numbers',
    ),
  ]);
  
  print(emailValidator(''));           // 输出: This field is required
  print(emailValidator('invalid'));    // 输出: Invalid email
  print(emailValidator('a@b.com'));    // 输出: null
  
  print(passwordValidator('short'));   // 输出: Minimum length is 8
  print(passwordValidator('longpassword'));  // 输出: Must contain letters and numbers
  print(passwordValidator('pass1234'));      // 输出: null
}
```

### 13.3 函数式数据处理管道

```dart
// 数据处理管道
class Pipeline<T> {
  final T value;
  
  Pipeline(this.value);
  
  Pipeline<R> map<R>(R Function(T) f) => Pipeline(f(value));
  
  Pipeline<T> filter(bool Function(T) predicate) {
    if (predicate(value)) return this;
    throw Exception('Filter failed');
  }
  
  Pipeline<T> tap(void Function(T) f) {
    f(value);
    return this;
  }
  
  Pipeline<R> flatMap<R>(Pipeline<R> Function(T) f) => f(value);
  
  T get() => value;
  
  R fold<R>(R Function(T) f) => f(value);
}

// 扩展方法支持列表管道
extension ListPipeline<T> on List<T> {
  ListPipeline<T> get pipeline => ListPipeline(this);
}

class ListPipeline<T> {
  final List<T> values;
  
  ListPipeline(this.values);
  
  ListPipeline<R> map<R>(R Function(T) f) => ListPipeline(values.map(f).toList());
  
  ListPipeline<T> where(bool Function(T) predicate) => 
      ListPipeline(values.where(predicate).toList());
  
  ListPipeline<T> take(int n) => ListPipeline(values.take(n).toList());
  
  ListPipeline<T> skip(int n) => ListPipeline(values.skip(n).toList());
  
  ListPipeline<T> distinct() => ListPipeline(values.toSet().toList());
  
  ListPipeline<T> sorted([int Function(T, T)? compare]) => 
      ListPipeline([...values]..sort(compare));
  
  R fold<R>(R initial, R Function(R, T) combine) => 
      values.fold(initial, combine);
  
  List<T> get toList => values;
  
  T? get firstOrNull => values.isEmpty ? null : values.first;
  
  T? get lastOrNull => values.isEmpty ? null : values.last;
}

void main() {
  // 单值管道
  var result = Pipeline(5)
    .map((n) => n * 2)
    .map((n) => n + 1)
    .tap((n) => print('Intermediate: $n'))  // 输出: Intermediate: 11
    .map((n) => n * n)
    .get();
  
  print('Result: $result');  // 输出: Result: 121
  
  // 列表管道
  var processed = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
    .pipeline
    .where((n) => n > 2)
    .distinct()
    .sorted()
    .take(5)
    .toList;
  
  print(processed);  // 输出: [3, 4, 5, 6, 9]
}
```

## 附录：函数相关速查表

| 特性 | 语法/关键字 | 说明 |
|------|------------|------|
| 函数定义 | `ReturnType name(params) {}` | 基本函数定义 |
| 箭头函数 | `=> expression` | 单表达式简写 |
| 必需位置参数 | `Type name` | 必须按顺序提供 |
| 可选位置参数 | `[Type? name]` 或 `[Type name = default]` | 可省略，按顺序 |
| 命名参数 | `{Type? name}` 或 `{Type name = default}` | 指定名称，顺序无关 |
| 必需命名参数 | `required Type name` | 必须提供 |
| 函数类型 | `ReturnType Function(ParamTypes)` | 函数类型注解 |
| typedef | `typedef Name = Type` | 函数类型别名 |
| 匿名函数 | `(params) {}` 或 `(params) => expr` | 无名称函数 |
| 闭包 | 函数捕获外部变量 | 词法作用域 |
| 同步生成器 | `sync*` + `yield` | 返回 Iterable |
| 异步生成器 | `async*` + `yield` | 返回 Stream |
| 构造函数 tear-off | `ClassName.new` | 引用构造函数 |
| 方法 tear-off | `ClassName.methodName` | 引用实例方法 |

---

本文档详细介绍了 Dart 语言的函数系统，从基础的函数定义、参数传递，到高级的闭包、高阶函数、生成器等特性。函数作为 Dart 的一等公民，为函数式编程提供了强大的支持。在实际 Flutter 开发中，熟练运用这些函数特性可以编写出更加简洁、可维护的代码。
